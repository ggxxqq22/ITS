{"version":3,"file":"togeojson.umd.js","sources":["../lib/shared.js","../lib/gpx.js","../lib/kml.js"],"sourcesContent":["// cast array x into numbers\n// get the content of a text node, if any\nexport function nodeVal(x) {\n  if (x && x.normalize) {\n    x.normalize();\n  }\n  return (x && x.textContent) || \"\";\n}\n","import { nodeVal } from \"./shared\";\n\nconst attributeNames = [\n  [\"speed\", \"speeds\"],\n  [\"course\", \"courses\"],\n  [\"hAcc\", \"hAccs\"],\n  [\"vAcc\", \"vAccs\"],\n  [\"heartRate\", \"heartRates\"]\n];\n\nfunction getLineStyle(extensions) {\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\")),\n        opacity = parseFloat(nodeVal(get1(lineStyle, \"opacity\"))),\n        width = parseFloat(nodeVal(get1(lineStyle, \"width\")));\n      if (color) style.stroke = color;\n      if (!isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      // GPX width is in mm, convert to px with 96 px per inch\n      if (!isNaN(width)) style[\"stroke-width\"] = (width * 96) / 25.4;\n    }\n  }\n  return style;\n}\n\n// get the contents of multiple text nodes, if present\nfunction getMulti(x, ys) {\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = nodeVal(n);\n  }\n  return o;\n}\nfunction getProperties(node) {\n  const prop = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\"\n  ]);\n  // Parse additional data from our Garmin extension(s)\n  const extensions = node.getElementsByTagNameNS(\n    \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n    \"*\"\n  );\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    // Ignore nested extensions, like those on routepoints or trackpoints\n    if (extension.parentNode.parentNode === node) {\n      prop[extension.tagName.replace(\":\", \"_\")] = nodeVal(extension);\n    }\n  }\n  const links = node.getElementsByTagName(\"link\");\n  if (links.length) prop.links = [];\n  for (let i = 0; i < links.length; i++) {\n    prop.links.push(\n      Object.assign(\n        { href: links[i].getAttribute(\"href\") },\n        getMulti(links[i], [\"text\", \"type\"])\n      )\n    );\n  }\n  return prop;\n}\n\n// one Y child of X, if any, otherwise null\nfunction get1(x, y) {\n  const n = x.getElementsByTagName(y);\n  return n.length ? n[0] : null;\n}\n\nfunction coordPair(x) {\n  const ll = [\n    parseFloat(x.getAttribute(\"lon\")),\n    parseFloat(x.getAttribute(\"lat\"))\n  ];\n  const ele = get1(x, \"ele\");\n  // handle namespaced attribute in browser\n  const heartRate = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e;\n  if (ele) {\n    e = parseFloat(nodeVal(ele));\n    if (!isNaN(e)) {\n      ll.push(e);\n    }\n  }\n  const result = {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n  };\n\n  const extensions = get1(x, \"extensions\");\n  if (extensions !== null) {\n    attributeNames\n      .map(r => r[0])\n      .filter(n => n !== \"heartrate\")\n      .forEach(name => {\n        const raw = get1(extensions, name);\n        if (raw !== null) {\n          const v = parseFloat(nodeVal(raw));\n          if (!isNaN(v)) {\n            result[name] = v;\n          }\n        }\n      });\n  }\n  return result;\n}\nfunction getRoute(node) {\n  const line = getPoints(node, \"rtept\");\n  if (!line.line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      getProperties(node),\n      getLineStyle(get1(node, \"extensions\"))\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line\n    }\n  };\n}\nfunction getPoints(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  const line = [];\n  const times = [];\n  const l = pts.length;\n  const extendedValues = {};\n  if (l < 2) return {}; // Invalid line in GeoJSON\n  for (let i = 0; i < l; i++) {\n    const c = coordPair(pts[i]);\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    attributeNames\n      .map(r => r[0])\n      .forEach(name => {\n        if (c[name] || extendedValues[name]) {\n          if (!extendedValues[name]) {\n            extendedValues[name] = Array(i).fill(null);\n          }\n          extendedValues[name].push(c[name] || null);\n        }\n      });\n  }\n  const result = {\n    line: line,\n    times: times\n  };\n  attributeNames.forEach(n => {\n    if (extendedValues[n[0]]) {\n      result[n[1]] = extendedValues[n[0]] || [];\n    }\n  });\n  return result;\n}\nfunction getTrack(node) {\n  const segments = node.getElementsByTagName(\"trkseg\");\n  const track = [];\n  const times = [];\n  const extendedValues = {};\n  let line;\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"trkpt\");\n    if (line) {\n      if (line.line) track.push(line.line);\n      if (line.times && line.times.length) times.push(line.times);\n\n      attributeNames\n        .map(r => r[1])\n        .forEach(name => {\n          if (\n            (extendedValues[name] && extendedValues[name].length) ||\n            (line[name] && line[name].length)\n          ) {\n            if (!extendedValues[name]) {\n              extendedValues[name] = [];\n            }\n            if (!extendedValues[name].length) {\n              for (let s = 0; s < i; s++) {\n                extendedValues[name].push(Array(track[s].length).fill(null));\n              }\n            }\n            if (line[name] && line[name].length) {\n              extendedValues[name].push(line[name]);\n            } else {\n              extendedValues[name].push(\n                Array(line.line.length || 0).fill(null)\n              );\n            }\n          }\n        });\n    }\n  }\n  if (track.length === 0) return;\n  const properties = Object.assign(\n    getProperties(node),\n    getLineStyle(get1(node, \"extensions\"))\n  );\n  if (times.length)\n    properties.coordTimes = track.length === 1 ? times[0] : times;\n  attributeNames.forEach(n => {\n    if (extendedValues[n[1]] && extendedValues[n[1]].length) {\n      properties[n[1]] =\n        track.length === 1 ? extendedValues[n[1]][0] : extendedValues[n[1]];\n    }\n  });\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: {\n      type: track.length === 1 ? \"LineString\" : \"MultiLineString\",\n      coordinates: track.length === 1 ? track[0] : track\n    }\n  };\n}\n\nfunction getPoint(node) {\n  return {\n    type: \"Feature\",\n    properties: Object.assign(getProperties(node), getMulti(node, [\"sym\"])),\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates\n    }\n  };\n}\n\nexport function* gpxGen(doc) {\n  const tracks = doc.getElementsByTagName(\"trk\");\n  const routes = doc.getElementsByTagName(\"rte\");\n  const waypoints = doc.getElementsByTagName(\"wpt\");\n\n  for (let i = 0; i < tracks.length; i++) {\n    const feature = getTrack(tracks[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < routes.length; i++) {\n    const feature = getRoute(routes[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < waypoints.length; i++) {\n    yield getPoint(waypoints[i]);\n  }\n}\n\nexport function gpx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(doc))\n  };\n}\n","import { nodeVal } from \"./shared\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n// generate a short, numeric hash of a string\nfunction okhash(x) {\n  if (!x || !x.length) return 0;\n  let h = 0;\n  for (let i = 0; i < x.length; i++) {\n    h = ((h << 5) - h + x.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\n// one Y child of X, if any, otherwise null\nfunction get1(x, y) {\n  const n = x.getElementsByTagName(y);\n  return n.length ? n[0] : null;\n}\n\n// get one coordinate from a coordinate array, if any\nfunction coord1(v) {\n  return v\n    .replace(removeSpace, \"\")\n    .split(\",\")\n    .map(parseFloat);\n}\n\n// get all coordinates from a coordinate array as [[],[]]\nfunction coord(v) {\n  return v\n    .replace(trimSpace, \"\")\n    .split(splitSpace)\n    .map(coord1);\n}\n\nfunction xml2str(node) {\n  if (node.xml !== undefined) return node.xml;\n  if (node.tagName) {\n    let output = node.tagName;\n    for (let i = 0; i < node.attributes.length; i++) {\n      output += node.attributes[i].name + node.attributes[i].value;\n    }\n    for (let i = 0; i < node.childNodes.length; i++) {\n      output += xml2str(node.childNodes[i]);\n    }\n    return output;\n  }\n  if (node.nodeName === \"#text\") {\n    return (node.nodeValue || node.value || \"\").trim();\n  }\n  if (node.nodeName === \"#cdata-section\") {\n    return node.nodeValue;\n  }\n  return \"\";\n}\n\nconst geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n\nfunction kmlColor(v) {\n  let color, opacity;\n  v = v || \"\";\n  if (v.substr(0, 1) === \"#\") {\n    v = v.substr(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    color = v;\n  }\n  if (v.length === 8) {\n    opacity = parseInt(v.substr(0, 2), 16) / 255;\n    color = \"#\" + v.substr(6, 2) + v.substr(4, 2) + v.substr(2, 2);\n  }\n  return [color, isNaN(opacity) ? undefined : opacity];\n}\n\nfunction gxCoords(root) {\n  let elems = root.getElementsByTagName(\"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0) elems = root.getElementsByTagName(\"gx:coord\");\n  for (let i = 0; i < elems.length; i++) {\n    coords.push(\n      nodeVal(elems[i])\n        .split(\" \")\n        .map(parseFloat)\n    );\n  }\n  const timeElems = root.getElementsByTagName(\"when\");\n  for (let j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n  return {\n    coords: coords,\n    times: times\n  };\n}\n\nfunction getGeometry(root) {\n  let geomNode;\n  let geomNodes;\n  let i;\n  let j;\n  let k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\")) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\")) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\")) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = root.getElementsByTagName(geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1(nodeVal(get1(geomNode, \"coordinates\")))\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord(nodeVal(get1(geomNode, \"coordinates\")))\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = geomNode.getElementsByTagName(\"LinearRing\"),\n            coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord(nodeVal(get1(rings[k], \"coordinates\"))));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return {\n    geoms: geoms,\n    coordTimes: coordTimes\n  };\n}\n\nfunction getPlacemark(root, styleIndex, styleMapIndex, styleByHash) {\n  const geomsAndTimes = getGeometry(root);\n  let i;\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  const visibility = get1(root, \"visibility\");\n\n  if (!geomsAndTimes.geoms.length) return;\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") {\n      styleUrl = \"#\" + styleUrl;\n    }\n\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n    }\n    // Try to populate the lineStyle or polyStyle since we got the style hash\n    const style = styleByHash[properties.styleHash];\n    if (style) {\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n      const iconStyle = get1(style, \"IconStyle\");\n      if (iconStyle) {\n        const icon = get1(iconStyle, \"Icon\");\n        if (icon) {\n          const href = nodeVal(get1(icon, \"href\"));\n          if (href) properties.icon = href;\n        }\n      }\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    properties.timespan = { begin: begin, end: end };\n  }\n  if (timeStamp) {\n    properties.timestamp = nodeVal(get1(timeStamp, \"when\"));\n  }\n  if (lineStyle) {\n    const linestyles = kmlColor(nodeVal(get1(lineStyle, \"color\"))),\n      color = linestyles[0],\n      opacity = linestyles[1],\n      width = parseFloat(nodeVal(get1(lineStyle, \"width\")));\n    if (color) properties.stroke = color;\n    if (!isNaN(opacity)) properties[\"stroke-opacity\"] = opacity;\n    if (!isNaN(width)) properties[\"stroke-width\"] = width;\n  }\n  if (polyStyle) {\n    const polystyles = kmlColor(nodeVal(get1(polyStyle, \"color\")));\n    const pcolor = polystyles[0];\n    const popacity = polystyles[1];\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (pcolor) properties.fill = pcolor;\n    if (!isNaN(popacity)) properties[\"fill-opacity\"] = popacity;\n    if (fill)\n      properties[\"fill-opacity\"] =\n        fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] =\n        outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = extendedData.getElementsByTagName(\"Data\"),\n      simpleDatas = extendedData.getElementsByTagName(\"SimpleData\");\n\n    for (i = 0; i < datas.length; i++) {\n      properties[datas[i].getAttribute(\"name\")] = nodeVal(\n        get1(datas[i], \"value\")\n      );\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[simpleDatas[i].getAttribute(\"name\")] = nodeVal(simpleDatas[i]);\n    }\n  }\n  if (visibility) {\n    properties.visibility = nodeVal(visibility);\n  }\n  if (geomsAndTimes.coordTimes.length) {\n    properties.coordTimes =\n      geomsAndTimes.coordTimes.length === 1\n        ? geomsAndTimes.coordTimes[0]\n        : geomsAndTimes.coordTimes;\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry:\n      geomsAndTimes.geoms.length === 1\n        ? geomsAndTimes.geoms[0]\n        : {\n            type: \"GeometryCollection\",\n            geometries: geomsAndTimes.geoms\n          },\n    properties: properties\n  };\n  if (root.getAttribute(\"id\")) feature.id = root.getAttribute(\"id\");\n  return feature;\n}\n\nexport function* kmlGen(doc) {\n  // styleindex keeps track of hashed styles in order to match feature\n  const styleIndex = {};\n  const styleByHash = {};\n  // stylemapindex keeps track of style maps to expose in properties\n  const styleMapIndex = {};\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = doc.getElementsByTagName(\"Placemark\");\n  const styles = doc.getElementsByTagName(\"Style\");\n  const styleMaps = doc.getElementsByTagName(\"StyleMap\");\n\n  for (let k = 0; k < styles.length; k++) {\n    const hash = okhash(xml2str(styles[k])).toString(16);\n    styleIndex[\"#\" + styles[k].getAttribute(\"id\")] = hash;\n    styleByHash[hash] = styles[k];\n  }\n  for (let l = 0; l < styleMaps.length; l++) {\n    styleIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = okhash(\n      xml2str(styleMaps[l])\n    ).toString(16);\n    const pairs = styleMaps[l].getElementsByTagName(\"Pair\");\n    const pairsMap = {};\n    for (let m = 0; m < pairs.length; m++) {\n      pairsMap[nodeVal(get1(pairs[m], \"key\"))] = nodeVal(\n        get1(pairs[m], \"styleUrl\")\n      );\n    }\n    styleMapIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = pairsMap;\n  }\n  for (let j = 0; j < placemarks.length; j++) {\n    const feature = getPlacemark(\n      placemarks[j],\n      styleIndex,\n      styleMapIndex,\n      styleByHash\n    );\n    if (feature) yield feature;\n  }\n}\n\nexport function kml(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(doc))\n  };\n}\n"],"names":["nodeVal","x","normalize","textContent","attributeNames","getLineStyle","extensions","style","lineStyle","get1","color","opacity","parseFloat","width","stroke","isNaN","getMulti","ys","o","n","k","length","getProperties","node","prop","getElementsByTagNameNS","i","extension","parentNode","tagName","replace","links","getElementsByTagName","push","Object","assign","href","getAttribute","y","coordPair","ll","ele","heartRate","time","e","result","coordinates","map","r","filter","forEach","name","raw","v","getRoute","line","getPoints","type","properties","geometry","pointname","pts","times","l","extendedValues","c","Array","fill","getTrack","segments","track","s","coordTimes","gpxGen","doc","tracks","routes","waypoints","feature","removeSpace","trimSpace","splitSpace","okhash","h","charCodeAt","coord1","split","coord","xml2str","undefined","xml","output","attributes","value","childNodes","nodeName","nodeValue","trim","geotypes","kmlColor","substr","parseInt","gxCoords","root","elems","coords","timeElems","j","getPlacemark","styleIndex","styleMapIndex","styleByHash","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","rings","address","styleUrl","description","timeSpan","timeStamp","extendedData","polyStyle","visibility","styleHash","styleMapHash","normal","iconStyle","icon","begin","end","timespan","timestamp","linestyles","polystyles","pcolor","popacity","outline","datas","simpleDatas","geometries","id","kmlGen","placemarks","styles","styleMaps","hash","toString","pairs","pairsMap","m","features","from"],"mappings":"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"}