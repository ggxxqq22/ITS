{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport WorkerThread from './worker-thread';\n\nvar WorkerPool = function () {\n  function WorkerPool(_ref) {\n    var source = _ref.source,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? 'unnamed' : _ref$name,\n        _ref$maxConcurrency = _ref.maxConcurrency,\n        maxConcurrency = _ref$maxConcurrency === void 0 ? 1 : _ref$maxConcurrency,\n        onMessage = _ref.onMessage,\n        _ref$onDebug = _ref.onDebug,\n        onDebug = _ref$onDebug === void 0 ? function () {} : _ref$onDebug;\n\n    _classCallCheck(this, WorkerPool);\n\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n  }\n\n  _createClass(WorkerPool, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.idleQueue.forEach(function (worker) {\n        return worker.destroy();\n      });\n      this.isDestroyed = true;\n    }\n  }, {\n    key: \"process\",\n    value: function process(data, jobName) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this.jobQueue.push({\n          data: data,\n          jobName: jobName,\n          resolve: resolve,\n          reject: reject\n        });\n\n        _this._startQueuedJob();\n      });\n    }\n  }, {\n    key: \"_startQueuedJob\",\n    value: function () {\n      var _startQueuedJob2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        var worker, job;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.jobQueue.length) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                worker = this._getAvailableWorker();\n\n                if (worker) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 5:\n                job = this.jobQueue.shift();\n                this.onDebug({\n                  message: 'processing',\n                  worker: worker.name,\n                  job: job.jobName,\n                  backlog: this.jobQueue.length\n                });\n                _context.prev = 7;\n                _context.t0 = job;\n                _context.next = 11;\n                return worker.process(job.data);\n\n              case 11:\n                _context.t1 = _context.sent;\n\n                _context.t0.resolve.call(_context.t0, _context.t1);\n\n                _context.next = 18;\n                break;\n\n              case 15:\n                _context.prev = 15;\n                _context.t2 = _context[\"catch\"](7);\n                job.reject(_context.t2);\n\n              case 18:\n                _context.prev = 18;\n\n                this._onWorkerDone(worker);\n\n                return _context.finish(18);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 15, 18, 21]]);\n      }));\n\n      function _startQueuedJob() {\n        return _startQueuedJob2.apply(this, arguments);\n      }\n\n      return _startQueuedJob;\n    }()\n  }, {\n    key: \"_onWorkerDone\",\n    value: function _onWorkerDone(worker) {\n      if (this.isDestroyed) {\n        worker.destroy();\n      } else {\n        this.idleQueue.push(worker);\n\n        this._startQueuedJob();\n      }\n    }\n  }, {\n    key: \"_getAvailableWorker\",\n    value: function _getAvailableWorker() {\n      if (this.idleQueue.length > 0) {\n        return this.idleQueue.shift();\n      }\n\n      if (this.count < this.maxConcurrency) {\n        this.count++;\n        var name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n        return new WorkerThread({\n          source: this.source,\n          onMessage: this.onMessage,\n          name: name\n        });\n      }\n\n      return null;\n    }\n  }]);\n\n  return WorkerPool;\n}();\n\nexport { WorkerPool as default };","map":{"version":3,"sources":["../../../../src/lib/worker-utils/worker-pool.js"],"names":["WorkerPool","source","name","maxConcurrency","onMessage","onDebug","worker","data","jobName","resolve","reject","length","job","message","backlog"],"mappings":"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","sourcesContent":["import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  constructor({source, name = 'unnamed', maxConcurrency = 1, onMessage, onDebug = () => {}}) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   */\n  process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    // @ts-ignore\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    try {\n      job.resolve(await worker.process(job.data));\n    } catch (error) {\n      job.reject(error);\n    } finally {\n      this._onWorkerDone(worker);\n    }\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n    } else {\n      this.idleQueue.push(worker);\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}