{"ast":null,"code":"\"use strict\";\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nvar types_1 = require(\"./types\");\n\nexports.getStepDecimals = function (step) {\n  var decimals = step.toString().split('.')[1];\n  return decimals ? decimals.length : 0;\n};\n\nfunction isTouchEvent(event) {\n  return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;\n}\n\nexports.isTouchEvent = isTouchEvent;\n\nfunction isStepDivisible(min, max, step) {\n  var res = (max - min) / step;\n  return parseInt(res.toString(), 10) === res;\n}\n\nexports.isStepDivisible = isStepDivisible;\n\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n  var BIG_NUM = 10e10;\n  value = Math.round(value * BIG_NUM) / BIG_NUM;\n\n  if (!allowOverlap) {\n    var prev = values[index - 1];\n    var next = values[index + 1];\n    if (prev && prev > value) return prev;\n    if (next && next < value) return next;\n  }\n\n  if (value > max) return max;\n  if (value < min) return min;\n  var inverter = min < 0 ? -1 : 1;\n  var remainder = Math.round(value * BIG_NUM - inverter * min * BIG_NUM) % Math.round(step * BIG_NUM);\n  var closestBigNum = Math.round(value * BIG_NUM - remainder);\n  var rounded = remainder === 0 ? value : closestBigNum / BIG_NUM;\n  var res = Math.abs(remainder / BIG_NUM) < step / 2 ? rounded : rounded + step * ((value > 0 ? 1 : 0) + (value < 0 ? -1 : 0) || +value);\n  var decimalPlaces = exports.getStepDecimals(step);\n  return parseFloat(res.toFixed(decimalPlaces));\n}\n\nexports.normalizeValue = normalizeValue;\n\nfunction relativeValue(value, min, max) {\n  return (value - min) / (max - min);\n}\n\nexports.relativeValue = relativeValue;\n\nfunction isVertical(direction) {\n  return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\n\nexports.isVertical = isVertical;\n\nfunction checkBoundaries(value, min, max) {\n  if (min >= max) {\n    throw new RangeError(\"min (\" + min + \") is equal/bigger than max (\" + max + \")\");\n  }\n\n  if (value < min) {\n    throw new RangeError(\"value (\" + value + \") is smaller than min (\" + min + \")\");\n  }\n\n  if (value > max) {\n    throw new RangeError(\"value (\" + value + \") is bigger than max (\" + max + \")\");\n  }\n}\n\nexports.checkBoundaries = checkBoundaries;\n\nfunction checkInitialOverlap(values) {\n  if (values.length < 2) return;\n\n  if (!values.slice(1).every(function (item, i) {\n    return values[i] <= item;\n  })) {\n    throw new RangeError(\"values={[\" + values + \"]} needs to be sorted when allowOverlap={false}\");\n  }\n}\n\nexports.checkInitialOverlap = checkInitialOverlap;\n\nfunction getMargin(element) {\n  var style = window.getComputedStyle(element);\n  return {\n    top: parseInt(style['margin-top'], 10),\n    bottom: parseInt(style['margin-bottom'], 10),\n    left: parseInt(style['margin-left'], 10),\n    right: parseInt(style['margin-right'], 10)\n  };\n}\n\nexports.getMargin = getMargin;\n\nfunction getPaddingAndBorder(element) {\n  var style = window.getComputedStyle(element);\n  return {\n    top: parseInt(style['padding-top'], 10) + parseInt(style['border-top-width'], 10),\n    bottom: parseInt(style['padding-bottom'], 10) + parseInt(style['border-bottom-width'], 10),\n    left: parseInt(style['padding-left'], 10) + parseInt(style['border-left-width'], 10),\n    right: parseInt(style['padding-right'], 10) + parseInt(style['border-right-width'], 10)\n  };\n}\n\nexports.getPaddingAndBorder = getPaddingAndBorder;\n\nfunction translateThumbs(elements, offsets, rtl) {\n  var inverter = rtl ? -1 : 1;\n  elements.forEach(function (element, index) {\n    return translate(element, inverter * offsets[index].x, offsets[index].y);\n  });\n}\n\nexports.translateThumbs = translateThumbs;\n\nfunction translate(element, x, y) {\n  element.style.transform = \"translate(\" + x + \"px, \" + y + \"px)\";\n}\n\nexports.translate = translate; // adapted from https://github.com/alexreardon/raf-schd\n\nexports.schd = function (fn) {\n  var lastArgs = [];\n  var frameId = null;\n\n  var wrapperFn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    lastArgs = args;\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      fn.apply(void 0, lastArgs);\n    });\n  };\n\n  return wrapperFn;\n};\n\nfunction replaceAt(values, index, value) {\n  var ret = values.slice(0);\n  ret[index] = value;\n  return ret;\n}\n\nexports.replaceAt = replaceAt;\n\nfunction getTrackBackground(_a) {\n  var values = _a.values,\n      colors = _a.colors,\n      min = _a.min,\n      max = _a.max,\n      _b = _a.direction,\n      direction = _b === void 0 ? types_1.Direction.Right : _b,\n      _c = _a.rtl,\n      rtl = _c === void 0 ? false : _c;\n\n  if (rtl && direction === types_1.Direction.Right) {\n    direction = types_1.Direction.Left;\n  } else if (rtl && types_1.Direction.Left) {\n    direction = types_1.Direction.Right;\n  }\n\n  var progress = values.map(function (value) {\n    return (value - min) / (max - min) * 100;\n  });\n  var middle = progress.reduce(function (acc, point, index) {\n    return acc + \", \" + colors[index] + \" \" + point + \"%, \" + colors[index + 1] + \" \" + point + \"%\";\n  }, '');\n  return \"linear-gradient(\" + direction + \", \" + colors[0] + \" 0%\" + middle + \", \" + colors[colors.length - 1] + \" 100%)\";\n}\n\nexports.getTrackBackground = getTrackBackground;\n\nfunction voidFn() {}\n\nexports.voidFn = voidFn;\n\nfunction assertUnreachable(x) {\n  throw new Error(\"Didn't expect to get here\");\n}\n\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\n\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n  if (valueToLabel === void 0) {\n    valueToLabel = function (value) {\n      return value;\n    };\n  }\n\n  var width = Math.ceil(__spreadArrays([thumbEl], Array.from(thumbEl.children)).reduce(function (width, el) {\n    var elWidth = Math.ceil(el.getBoundingClientRect().width);\n    /**\n     * If a label contains a merged label value, it won't return the true\n     * label width for that Thumb. Clone the label and change the value\n     * to that individual Thumb value in order to grab the true width.\n     */\n\n    if (el.innerText && el.innerText.includes(separator) && el.childElementCount === 0) {\n      var elClone = el.cloneNode(true);\n      elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n      elClone.style.visibility = 'hidden';\n      document.body.appendChild(elClone);\n      elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n      document.body.removeChild(elClone);\n    }\n\n    return elWidth > width ? elWidth : width;\n  }, thumbEl.getBoundingClientRect().width));\n  return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\n\n\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n  if (valueToLabel === void 0) {\n    valueToLabel = function (value) {\n      return value;\n    };\n  }\n\n  var overlaps = [];\n  /**\n   * Recursive function for building the overlaps Array\n   * If an overlap is found, find the overlaps for that overlap\n   * @param thumbIndex current Thumb index to find overlaps from\n   */\n\n  var buildOverlaps = function (thumbIndex) {\n    var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n    var thumbX = offsets[thumbIndex].x;\n    /**\n     * Iterate through the Thumb offsets, if there is a match\n     * add the thumbIndex and siblingIndex to the overlaps Array\n     *\n     * Then build overlaps from the overlapping siblingIndex\n     */\n\n    offsets.forEach(function (_a, siblingIndex) {\n      var siblingX = _a.x;\n      var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n\n      if (thumbIndex !== siblingIndex && (thumbX >= siblingX && thumbX <= siblingX + siblingWidth || thumbX + thumbXWidth >= siblingX && thumbX + thumbXWidth <= siblingX + siblingWidth)) {\n        if (!overlaps.includes(siblingIndex)) {\n          overlaps.push(thumbIndex);\n          overlaps.push(siblingIndex);\n          overlaps = __spreadArrays(overlaps, [thumbIndex, siblingIndex]);\n          buildOverlaps(siblingIndex);\n        }\n      }\n    });\n  };\n\n  buildOverlaps(index); // Sort and remove duplicates from the built overlaps\n\n  return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\n\n\nexports.useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n  if (step === void 0) {\n    step = 0.1;\n  }\n\n  if (separator === void 0) {\n    separator = ' - ';\n  }\n\n  if (valueToLabel === void 0) {\n    valueToLabel = function (value) {\n      return value;\n    };\n  }\n\n  var decimalPlaces = exports.getStepDecimals(step); // Create initial label style and value. Label value defaults to thumb value\n\n  var _a = react_1.useState({}),\n      labelStyle = _a[0],\n      setLabelStyle = _a[1];\n\n  var _b = react_1.useState(valueToLabel(values[index].toFixed(decimalPlaces))),\n      labelValue = _b[0],\n      setLabelValue = _b[1]; // When the rangeRef or values change, update the Thumb label values and styling\n\n\n  react_1.useEffect(function () {\n    if (rangeRef) {\n      var thumbs = rangeRef.getThumbs();\n      if (thumbs.length < 1) return;\n      var newStyle = {};\n      var offsets_1 = rangeRef.getOffsets();\n      /**\n       * Get any overlaps for the given Thumb index. This must return all linked\n       * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n       * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n       * 2, 3 and 4 also.\n       */\n\n      var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel); // Set a default label value of the Thumb value\n\n      var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n      /**\n       * If there are overlaps for the Thumb, we need to calculate the correct\n       * Label value along with the relevant styling. We only want to show a Label\n       * for the left most Thumb in an overlapping set.\n       * All other Thumbs will be set to display: none.\n       */\n\n      if (overlaps.length) {\n        /**\n         * Get an Array of the offsets for the overlapping Thumbs\n         * This is so we can determine if the Thumb we are looking at\n         * is the left most thumb in an overlapping set\n         */\n        var offsetsX = overlaps.reduce(function (a, c, i, s) {\n          return a.length ? __spreadArrays(a, [offsets_1[s[i]].x]) : [offsets_1[s[i]].x];\n        }, []);\n        /**\n         * If our Thumb is the left most Thumb, we can build a Label value\n         * and set the style for that Label\n         */\n\n        if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n          /**\n           * First calculate the Label value. To do this,\n           * grab all the values for the Thumbs in our overlaps.\n           * Then convert that to a Set and sort it whilst removing duplicates.\n           */\n          var labelValues_1 = [];\n          overlaps.forEach(function (thumb) {\n            labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n          });\n          /**\n           *  Update the labelValue with the resulting Array\n           *  joined by our defined separator\n           */\n\n          labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) {\n            return parseFloat(a) - parseFloat(b);\n          }))).map(valueToLabel).join(separator);\n          /**\n           * Lastly, build the label styling. The label styling will\n           * position the label and apply a transform so that it's centered.\n           * We want the center point between the left edge of the left most Thumb\n           * and the right edge of the right most Thumb.\n           */\n\n          var first = Math.min.apply(Math, offsetsX);\n          var last = Math.max.apply(Math, offsetsX);\n          var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n          newStyle.left = Math.abs(first - (last + lastWidth)) / 2 + \"px\";\n          newStyle.transform = 'translate(-50%, 0)';\n        } else {\n          // If the Thumb isn't the left most Thumb, hide the Label!\n          newStyle.visibility = 'hidden';\n        }\n      } // Update the label value and style\n\n\n      setLabelValue(labelValue_1);\n      setLabelStyle(newStyle);\n    }\n  }, [rangeRef, values]);\n  return [labelValue, labelStyle];\n};","map":{"version":3,"sources":["/home/zhiguangda/ITS/deckgl/node_modules/react-range/lib/utils.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","Object","defineProperty","exports","value","react_1","require","types_1","getStepDecimals","step","decimals","toString","split","isTouchEvent","event","touches","changedTouches","isStepDivisible","min","max","res","parseInt","normalizeValue","index","allowOverlap","values","BIG_NUM","Math","round","prev","next","inverter","remainder","closestBigNum","rounded","abs","decimalPlaces","parseFloat","toFixed","relativeValue","isVertical","direction","Direction","Up","Down","checkBoundaries","RangeError","checkInitialOverlap","slice","every","item","getMargin","element","style","window","getComputedStyle","top","bottom","left","right","getPaddingAndBorder","translateThumbs","elements","offsets","rtl","forEach","translate","x","y","transform","schd","fn","lastArgs","frameId","wrapperFn","args","_i","requestAnimationFrame","apply","replaceAt","ret","getTrackBackground","_a","colors","_b","Right","_c","Left","progress","map","middle","reduce","acc","point","voidFn","assertUnreachable","Error","getThumbWidth","thumbEl","separator","valueToLabel","width","ceil","from","children","el","elWidth","getBoundingClientRect","innerText","includes","childElementCount","elClone","cloneNode","innerHTML","visibility","document","body","appendChild","removeChild","getOverlaps","thumbs","overlaps","buildOverlaps","thumbIndex","thumbXWidth","thumbX","siblingIndex","siblingX","siblingWidth","push","Set","sort","useThumbOverlap","rangeRef","useState","labelStyle","setLabelStyle","labelValue","setLabelValue","useEffect","getThumbs","newStyle","offsets_1","getOffsets","labelValue_1","offsetsX","c","labelValues_1","thumb","b","join","first","last","lastWidth","indexOf"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar react_1 = require(\"react\");\nvar types_1 = require(\"./types\");\nexports.getStepDecimals = function (step) {\n    var decimals = step.toString().split('.')[1];\n    return decimals ? decimals.length : 0;\n};\nfunction isTouchEvent(event) {\n    return ((event.touches && event.touches.length) ||\n        (event.changedTouches && event.changedTouches.length));\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    return parseInt(res.toString(), 10) === res;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value)\n            return prev;\n        if (next && next < value)\n            return next;\n    }\n    if (value > max)\n        return max;\n    if (value < min)\n        return min;\n    var inverter = min < 0 ? -1 : 1;\n    var remainder = Math.round(value * BIG_NUM - inverter * min * BIG_NUM) %\n        Math.round(step * BIG_NUM);\n    var closestBigNum = Math.round(value * BIG_NUM - remainder);\n    var rounded = remainder === 0 ? value : closestBigNum / BIG_NUM;\n    var res = Math.abs(remainder / BIG_NUM) < step / 2\n        ? rounded\n        : rounded + step * (((value > 0) ? 1 : 0) + ((value < 0) ? -1 : 0) || +value);\n    var decimalPlaces = exports.getStepDecimals(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\" + min + \") is equal/bigger than max (\" + max + \")\");\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\" + value + \") is smaller than min (\" + min + \")\");\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\" + value + \") is bigger than max (\" + max + \")\");\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2)\n        return;\n    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {\n        throw new RangeError(\"values={[\" + values + \"]} needs to be sorted when allowOverlap={false}\");\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['margin-top'], 10),\n        bottom: parseInt(style['margin-bottom'], 10),\n        left: parseInt(style['margin-left'], 10),\n        right: parseInt(style['margin-right'], 10)\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['padding-top'], 10) + parseInt(style['border-top-width'], 10),\n        bottom: parseInt(style['padding-bottom'], 10) + parseInt(style['border-bottom-width'], 10),\n        left: parseInt(style['padding-left'], 10) + parseInt(style['border-left-width'], 10),\n        right: parseInt(style['padding-right'], 10) + parseInt(style['border-right-width'], 10),\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function (element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\" + x + \"px, \" + y + \"px)\";\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nexports.schd = function (fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function () {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    }\n    else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    var progress = values.map(function (value) { return ((value - min) / (max - min)) * 100; });\n    var middle = progress.reduce(function (acc, point, index) {\n        return acc + \", \" + colors[index] + \" \" + point + \"%, \" + colors[index + 1] + \" \" + point + \"%\";\n    }, '');\n    return \"linear-gradient(\" + direction + \", \" + colors[0] + \" 0%\" + middle + \", \" + colors[colors.length - 1] + \" 100%)\";\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() { }\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var width = Math.ceil(__spreadArrays([thumbEl], Array.from(thumbEl.children)).reduce(function (width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */\n        if (el.innerText &&\n            el.innerText.includes(separator) &&\n            el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = 'hidden';\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */\n    var buildOverlaps = function (thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */\n        offsets.forEach(function (_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex &&\n                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||\n                    (thumbX + thumbXWidth >= siblingX &&\n                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArrays(overlaps, [thumbIndex, siblingIndex]);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nexports.useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) { step = 0.1; }\n    if (separator === void 0) { separator = ' - '; }\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var decimalPlaces = exports.getStepDecimals(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = react_1.useState({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = react_1.useState(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    react_1.useEffect(function () {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1)\n                return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */\n            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */\n            if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */\n                var offsetsX = overlaps.reduce(function (a, c, i, s) {\n                    return a.length ? __spreadArrays(a, [offsets_1[s[i]].x]) : [offsets_1[s[i]].x];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */\n                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */\n                    var labelValues_1 = [];\n                    overlaps.forEach(function (thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */\n                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))\n                        .map(valueToLabel)\n                        .join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */\n                    var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n                    newStyle.left = Math.abs(first - (last + lastWidth)) / 2 + \"px\";\n                    newStyle.transform = 'translate(-50%, 0)';\n                }\n                else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = 'hidden';\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [rangeRef, values]);\n    return [labelValue, labelStyle];\n};\n"]},"metadata":{},"sourceType":"script"}