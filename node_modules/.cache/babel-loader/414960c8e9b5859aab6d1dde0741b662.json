{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nvar NUM_DIMENSIONS = {\n  0: 2,\n  1: 3,\n  2: 3,\n  3: 4\n};\nexport default function parseWKB(buffer) {\n  var view = new DataView(buffer);\n  var offset = 0;\n  var littleEndian = view.getUint8(offset) === 1;\n  offset++;\n  var geometryCode = view.getUint32(offset, littleEndian);\n  offset += 4;\n  var geometryType = geometryCode % 1000;\n  var dimension = NUM_DIMENSIONS[(geometryCode - geometryType) / 1000];\n\n  switch (geometryType) {\n    case 1:\n      var point = parsePoint(view, offset, dimension, littleEndian);\n      delete point.offset;\n      point.type = 'Point';\n      return point;\n\n    case 2:\n      var line = parseLineString(view, offset, dimension, littleEndian);\n      delete line.offset;\n      line.type = 'LineString';\n      return line;\n\n    case 3:\n      var polygon = parsePolygon(view, offset, dimension, littleEndian);\n      delete polygon.offset;\n      polygon.type = 'Polygon';\n      return polygon;\n\n    case 4:\n      var multiPoint = parseMultiPoint(view, offset, dimension, littleEndian);\n      multiPoint.type = 'Point';\n      return multiPoint;\n\n    case 5:\n      var multiLine = parseMultiLineString(view, offset, dimension, littleEndian);\n      multiLine.type = 'LineString';\n      return multiLine;\n\n    case 6:\n      var multiPolygon = parseMultiPolygon(view, offset, dimension, littleEndian);\n      multiPolygon.type = 'Polygon';\n      return multiPolygon;\n\n    default:\n      assert(false, \"Unsupported geometry type: \".concat(geometryType));\n  }\n\n  return null;\n}\n\nfunction parsePoint(view, offset, dimension, littleEndian) {\n  var positions = new Float64Array(dimension);\n\n  for (var i = 0; i < dimension; i++) {\n    positions[i] = view.getFloat64(offset, littleEndian);\n    offset += 8;\n  }\n\n  return {\n    positions: {\n      value: positions,\n      size: dimension\n    },\n    offset: offset\n  };\n}\n\nfunction parseLineString(view, offset, dimension, littleEndian) {\n  var nPoints = view.getUint32(offset, littleEndian);\n  offset += 4;\n  var positions = new Float64Array(nPoints * dimension);\n\n  for (var i = 0; i < nPoints * dimension; i++) {\n    positions[i] = view.getFloat64(offset, littleEndian);\n    offset += 8;\n  }\n\n  var pathIndices = [0];\n\n  if (nPoints > 0) {\n    pathIndices.push(nPoints);\n  }\n\n  return {\n    positions: {\n      value: positions,\n      size: dimension\n    },\n    pathIndices: {\n      value: new Uint16Array(pathIndices),\n      size: 1\n    },\n    offset: offset\n  };\n}\n\nvar cumulativeSum = function cumulativeSum(sum) {\n  return function (value) {\n    return sum += value;\n  };\n};\n\nfunction parsePolygon(view, offset, dimension, littleEndian) {\n  var nRings = view.getUint32(offset, littleEndian);\n  offset += 4;\n  var rings = [];\n\n  for (var i = 0; i < nRings; i++) {\n    var parsed = parseLineString(view, offset, dimension, littleEndian);\n    var positions = parsed.positions;\n    offset = parsed.offset;\n    rings.push(positions.value);\n  }\n\n  var concatenatedPositions = new Float64Array(concatTypedArrays(rings).buffer);\n  var polygonIndices = [0];\n\n  if (concatenatedPositions.length > 0) {\n    polygonIndices.push(concatenatedPositions.length / dimension);\n  }\n\n  var primitivePolygonIndices = rings.map(function (l) {\n    return l.length / dimension;\n  }).map(cumulativeSum(0));\n  primitivePolygonIndices.unshift(0);\n  return {\n    positions: {\n      value: concatenatedPositions,\n      size: dimension\n    },\n    polygonIndices: {\n      value: new Uint16Array(polygonIndices),\n      size: 1\n    },\n    primitivePolygonIndices: {\n      value: new Uint16Array(primitivePolygonIndices),\n      size: 1\n    },\n    offset: offset\n  };\n}\n\nfunction parseMultiPoint(view, offset, dimension, littleEndian) {\n  var nPoints = view.getUint32(offset, littleEndian);\n  offset += 4;\n  var points = [];\n\n  for (var i = 0; i < nPoints; i++) {\n    var littleEndianPoint = view.getUint8(offset) === 1;\n    offset++;\n    assert(view.getUint32(offset, littleEndianPoint) % 1000 === 1, 'Inner geometries of MultiPoint not of type Point');\n    offset += 4;\n    var parsed = parsePoint(view, offset, dimension, littleEndianPoint);\n    var positions = parsed.positions;\n    offset = parsed.offset;\n    points.push(positions.value);\n  }\n\n  var concatenatedPositions = new Float64Array(concatTypedArrays(points).buffer);\n  return {\n    positions: {\n      value: concatenatedPositions,\n      size: dimension\n    }\n  };\n}\n\nfunction parseMultiLineString(view, offset, dimension, littleEndian) {\n  var nLines = view.getUint32(offset, littleEndian);\n  offset += 4;\n  var lines = [];\n\n  for (var i = 0; i < nLines; i++) {\n    var littleEndianLine = view.getUint8(offset) === 1;\n    offset++;\n    assert(view.getUint32(offset, littleEndianLine) % 1000 === 2, 'Inner geometries of MultiLineString not of type LineString');\n    offset += 4;\n    var parsed = parseLineString(view, offset, dimension, littleEndianLine);\n    var positions = parsed.positions;\n    offset = parsed.offset;\n    lines.push(positions.value);\n  }\n\n  var concatenatedPositions = new Float64Array(concatTypedArrays(lines).buffer);\n  var pathIndices = lines.map(function (l) {\n    return l.length / dimension;\n  }).map(cumulativeSum(0));\n  pathIndices.unshift(0);\n  return {\n    positions: {\n      value: concatenatedPositions,\n      size: dimension\n    },\n    pathIndices: {\n      value: new Uint16Array(pathIndices),\n      size: 1\n    }\n  };\n}\n\nfunction parseMultiPolygon(view, offset, dimension, littleEndian) {\n  var nPolygons = view.getUint32(offset, littleEndian);\n  offset += 4;\n  var polygons = [];\n  var primitivePolygons = [];\n\n  for (var i = 0; i < nPolygons; i++) {\n    var littleEndianPolygon = view.getUint8(offset) === 1;\n    offset++;\n    assert(view.getUint32(offset, littleEndianPolygon) % 1000 === 3, 'Inner geometries of MultiPolygon not of type Polygon');\n    offset += 4;\n    var parsed = parsePolygon(view, offset, dimension, littleEndianPolygon);\n    var positions = parsed.positions,\n        _primitivePolygonIndices = parsed.primitivePolygonIndices;\n    offset = parsed.offset;\n    polygons.push(positions.value);\n    primitivePolygons.push(_primitivePolygonIndices.value);\n  }\n\n  var concatenatedPositions = new Float64Array(concatTypedArrays(polygons).buffer);\n  var polygonIndices = polygons.map(function (p) {\n    return p.length / dimension;\n  }).map(cumulativeSum(0));\n  polygonIndices.unshift(0);\n  var primitivePolygonIndices = [0];\n\n  for (var _i = 0, _primitivePolygons = primitivePolygons; _i < _primitivePolygons.length; _i++) {\n    var primitivePolygon = _primitivePolygons[_i];\n    primitivePolygonIndices.push.apply(primitivePolygonIndices, _toConsumableArray(primitivePolygon.filter(function (x) {\n      return x > 0;\n    }).map(function (x) {\n      return x + primitivePolygonIndices[primitivePolygonIndices.length - 1];\n    })));\n  }\n\n  return {\n    positions: {\n      value: concatenatedPositions,\n      size: dimension\n    },\n    polygonIndices: {\n      value: new Uint16Array(polygonIndices),\n      size: 1\n    },\n    primitivePolygonIndices: {\n      value: new Uint16Array(primitivePolygonIndices),\n      size: 1\n    }\n  };\n}\n\nfunction concatTypedArrays(arrays) {\n  var byteLength = 0;\n\n  for (var i = 0; i < arrays.length; ++i) {\n    byteLength += arrays[i].byteLength;\n  }\n\n  var buffer = new Uint8Array(byteLength);\n  var byteOffset = 0;\n\n  for (var _i2 = 0; _i2 < arrays.length; ++_i2) {\n    var data = new Uint8Array(arrays[_i2].buffer);\n    byteLength = data.length;\n\n    for (var j = 0; j < byteLength; ++j) {\n      buffer[byteOffset++] = data[j];\n    }\n  }\n\n  return buffer;\n}\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"Error parsing Well-Known Binary. \".concat(message));\n  }\n}","map":{"version":3,"sources":["../../../src/lib/parse-wkb.js"],"names":["NUM_DIMENSIONS","view","offset","littleEndian","geometryCode","geometryType","dimension","point","parsePoint","line","parseLineString","polygon","parsePolygon","multiPoint","parseMultiPoint","multiLine","parseMultiLineString","multiPolygon","parseMultiPolygon","assert","positions","i","value","size","nPoints","pathIndices","cumulativeSum","sum","nRings","rings","parsed","concatenatedPositions","concatTypedArrays","polygonIndices","primitivePolygonIndices","l","points","littleEndianPoint","nLines","lines","littleEndianLine","nPolygons","polygons","primitivePolygons","littleEndianPolygon","p","primitivePolygon","x","byteLength","arrays","buffer","byteOffset","data","j"],"mappings":";AAAA,IAAMA,cAAc,GAAG;AACrB,KADqB,CAAA;AAErB,KAFqB,CAAA;AAGrB,KAHqB,CAAA;AAIrB,KAAG;AAJkB,CAAvB;AAOA,eAAe,SAAA,QAAA,CAAA,MAAA,EAA0B;AACvC,MAAMC,IAAI,GAAG,IAAA,QAAA,CAAb,MAAa,CAAb;AACA,MAAIC,MAAM,GAAV,CAAA;AAGA,MAAMC,YAAY,GAAGF,IAAI,CAAJA,QAAAA,CAAAA,MAAAA,MAArB,CAAA;AACAC,EAAAA,MAAM;AAGN,MAAME,YAAY,GAAGH,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAArB,YAAqBA,CAArB;AACAC,EAAAA,MAAM,IAANA,CAAAA;AAEA,MAAMG,YAAY,GAAGD,YAAY,GAAjC,IAAA;AACA,MAAME,SAAS,GAAGN,cAAc,CAAC,CAACI,YAAY,GAAb,YAAA,IAAjC,IAAgC,CAAhC;;AAEA,UAAA,YAAA;AACE,SAAA,CAAA;AACE,UAAMG,KAAK,GAAGC,UAAU,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAxB,YAAwB,CAAxB;AACA,aAAOD,KAAK,CAAZ,MAAA;AACAA,MAAAA,KAAK,CAALA,IAAAA,GAAAA,OAAAA;AACA,aAAA,KAAA;;AACF,SAAA,CAAA;AACE,UAAME,IAAI,GAAGC,eAAe,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAA5B,YAA4B,CAA5B;AACA,aAAOD,IAAI,CAAX,MAAA;AACAA,MAAAA,IAAI,CAAJA,IAAAA,GAAAA,YAAAA;AACA,aAAA,IAAA;;AACF,SAAA,CAAA;AACE,UAAME,OAAO,GAAGC,YAAY,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAA5B,YAA4B,CAA5B;AACA,aAAOD,OAAO,CAAd,MAAA;AACAA,MAAAA,OAAO,CAAPA,IAAAA,GAAAA,SAAAA;AACA,aAAA,OAAA;;AACF,SAAA,CAAA;AACE,UAAME,UAAU,GAAGC,eAAe,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAlC,YAAkC,CAAlC;AACAD,MAAAA,UAAU,CAAVA,IAAAA,GAAAA,OAAAA;AACA,aAAA,UAAA;;AACF,SAAA,CAAA;AACE,UAAME,SAAS,GAAGC,oBAAoB,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAtC,YAAsC,CAAtC;AACAD,MAAAA,SAAS,CAATA,IAAAA,GAAAA,YAAAA;AACA,aAAA,SAAA;;AACF,SAAA,CAAA;AACE,UAAME,YAAY,GAAGC,iBAAiB,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAtC,YAAsC,CAAtC;AACAD,MAAAA,YAAY,CAAZA,IAAAA,GAAAA,SAAAA;AACA,aAAA,YAAA;;AAIF;AACEE,MAAAA,MAAM,CAAA,KAAA,EAAA,8BAAA,MAAA,CAANA,YAAM,CAAA,CAANA;AAhCJ;;AAmCA,SAAA,IAAA;AACD;;AAGD,SAAA,UAAA,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAA,YAAA,EAA2D;AACzD,MAAMC,SAAS,GAAG,IAAA,YAAA,CAAlB,SAAkB,CAAlB;;AACA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,SAAA,EAA+BA,CAA/B,EAAA,EAAoC;AAClCD,IAAAA,SAAS,CAATA,CAAS,CAATA,GAAenB,IAAI,CAAJA,UAAAA,CAAAA,MAAAA,EAAfmB,YAAenB,CAAfmB;AACAlB,IAAAA,MAAM,IAANA,CAAAA;AACD;;AAED,SAAO;AAACkB,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAN,SAAA;AAAmBC,MAAAA,IAAI,EAAEjB;AAAzB,KAAZ;AAAiDJ,IAAAA,MAAM,EAANA;AAAjD,GAAP;AACD;;AAED,SAAA,eAAA,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAA,YAAA,EAAgE;AAC9D,MAAMsB,OAAO,GAAGvB,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAhB,YAAgBA,CAAhB;AACAC,EAAAA,MAAM,IAANA,CAAAA;AAGA,MAAMkB,SAAS,GAAG,IAAA,YAAA,CAAiBI,OAAO,GAA1C,SAAkB,CAAlB;;AACA,OAAK,IAAIH,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGG,OAAO,GAA3B,SAAA,EAAyCH,CAAzC,EAAA,EAA8C;AAC5CD,IAAAA,SAAS,CAATA,CAAS,CAATA,GAAenB,IAAI,CAAJA,UAAAA,CAAAA,MAAAA,EAAfmB,YAAenB,CAAfmB;AACAlB,IAAAA,MAAM,IAANA,CAAAA;AACD;;AAED,MAAMuB,WAAW,GAAG,CAApB,CAAoB,CAApB;;AACA,MAAID,OAAO,GAAX,CAAA,EAAiB;AACfC,IAAAA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA;AACD;;AAED,SAAO;AACLL,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAN,SAAA;AAAmBC,MAAAA,IAAI,EAAEjB;AAAzB,KADN;AAELmB,IAAAA,WAAW,EAAE;AAACH,MAAAA,KAAK,EAAE,IAAA,WAAA,CAAR,WAAQ,CAAR;AAAsCC,MAAAA,IAAI,EAAE;AAA5C,KAFR;AAGLrB,IAAAA,MAAM,EAANA;AAHK,GAAP;AAKD;;AAGD,IAAMwB,aAAa,GAAG,SAAhBA,aAAgB,CAAA,GAAA,EAAG;AAAA,SAAI,UAAA,KAAA,EAAK;AAAA,WAAKC,GAAG,IAAR,KAAA;AAAT,GAAA;AAAzB,CAAA;;AAEA,SAAA,YAAA,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAA,YAAA,EAA6D;AAC3D,MAAMC,MAAM,GAAG3B,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAf,YAAeA,CAAf;AACAC,EAAAA,MAAM,IAANA,CAAAA;AAEA,MAAM2B,KAAK,GAAX,EAAA;;AACA,OAAK,IAAIR,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,MAAA,EAA4BA,CAA5B,EAAA,EAAiC;AAC/B,QAAMS,MAAM,GAAGpB,eAAe,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAA9B,YAA8B,CAA9B;AAD+B,QAExBU,SAFwB,GAEXU,MAFW,CAAA,SAAA;AAG/B5B,IAAAA,MAAM,GAAG4B,MAAM,CAAf5B,MAAAA;AACA2B,IAAAA,KAAK,CAALA,IAAAA,CAAWT,SAAS,CAApBS,KAAAA;AACD;;AAED,MAAME,qBAAqB,GAAG,IAAA,YAAA,CAAiBC,iBAAiB,CAAjBA,KAAiB,CAAjBA,CAA/C,MAA8B,CAA9B;AACA,MAAMC,cAAc,GAAG,CAAvB,CAAuB,CAAvB;;AACA,MAAIF,qBAAqB,CAArBA,MAAAA,GAAJ,CAAA,EAAsC;AACpCE,IAAAA,cAAc,CAAdA,IAAAA,CAAoBF,qBAAqB,CAArBA,MAAAA,GAApBE,SAAAA;AACD;;AACD,MAAMC,uBAAuB,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,CAAA,EAAC;AAAA,WAAIC,CAAC,CAADA,MAAAA,GAAJ,SAAA;AAAX,GAAA,EAAA,GAAA,CAAyCT,aAAa,CAAtF,CAAsF,CAAtD,CAAhC;AACAQ,EAAAA,uBAAuB,CAAvBA,OAAAA,CAAAA,CAAAA;AAEA,SAAO;AACLd,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAN,qBAAA;AAA+BC,MAAAA,IAAI,EAAEjB;AAArC,KADN;AAEL2B,IAAAA,cAAc,EAAE;AACdX,MAAAA,KAAK,EAAE,IAAA,WAAA,CADO,cACP,CADO;AAEdC,MAAAA,IAAI,EAAE;AAFQ,KAFX;AAMLW,IAAAA,uBAAuB,EAAE;AAACZ,MAAAA,KAAK,EAAE,IAAA,WAAA,CAAR,uBAAQ,CAAR;AAAkDC,MAAAA,IAAI,EAAE;AAAxD,KANpB;AAOLrB,IAAAA,MAAM,EAANA;AAPK,GAAP;AASD;;AAED,SAAA,eAAA,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAA,YAAA,EAAgE;AAC9D,MAAMsB,OAAO,GAAGvB,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAhB,YAAgBA,CAAhB;AACAC,EAAAA,MAAM,IAANA,CAAAA;AAEA,MAAMkC,MAAM,GAAZ,EAAA;;AACA,OAAK,IAAIf,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,OAAA,EAA6BA,CAA7B,EAAA,EAAkC;AAEhC,QAAMgB,iBAAiB,GAAGpC,IAAI,CAAJA,QAAAA,CAAAA,MAAAA,MAA1B,CAAA;AACAC,IAAAA,MAAM;AAGNiB,IAAAA,MAAM,CACJlB,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAAA,iBAAAA,IAAAA,IAAAA,KADI,CAAA,EAANkB,kDAAM,CAANA;AAIAjB,IAAAA,MAAM,IAANA,CAAAA;AAEA,QAAM4B,MAAM,GAAGtB,UAAU,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAzB,iBAAyB,CAAzB;AAZgC,QAazBY,SAbyB,GAaZU,MAbY,CAAA,SAAA;AAchC5B,IAAAA,MAAM,GAAG4B,MAAM,CAAf5B,MAAAA;AACAkC,IAAAA,MAAM,CAANA,IAAAA,CAAYhB,SAAS,CAArBgB,KAAAA;AACD;;AAED,MAAML,qBAAqB,GAAG,IAAA,YAAA,CAAiBC,iBAAiB,CAAjBA,MAAiB,CAAjBA,CAA/C,MAA8B,CAA9B;AAEA,SAAO;AACLZ,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAN,qBAAA;AAA+BC,MAAAA,IAAI,EAAEjB;AAArC;AADN,GAAP;AAGD;;AAED,SAAA,oBAAA,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAA,YAAA,EAAqE;AACnE,MAAMgC,MAAM,GAAGrC,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAf,YAAeA,CAAf;AACAC,EAAAA,MAAM,IAANA,CAAAA;AAEA,MAAMqC,KAAK,GAAX,EAAA;;AACA,OAAK,IAAIlB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,MAAA,EAA4BA,CAA5B,EAAA,EAAiC;AAE/B,QAAMmB,gBAAgB,GAAGvC,IAAI,CAAJA,QAAAA,CAAAA,MAAAA,MAAzB,CAAA;AACAC,IAAAA,MAAM;AAGNiB,IAAAA,MAAM,CACJlB,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAAA,gBAAAA,IAAAA,IAAAA,KADI,CAAA,EAANkB,4DAAM,CAANA;AAIAjB,IAAAA,MAAM,IAANA,CAAAA;AAEA,QAAM4B,MAAM,GAAGpB,eAAe,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAA9B,gBAA8B,CAA9B;AAZ+B,QAaxBU,SAbwB,GAaXU,MAbW,CAAA,SAAA;AAc/B5B,IAAAA,MAAM,GAAG4B,MAAM,CAAf5B,MAAAA;AACAqC,IAAAA,KAAK,CAALA,IAAAA,CAAWnB,SAAS,CAApBmB,KAAAA;AACD;;AAED,MAAMR,qBAAqB,GAAG,IAAA,YAAA,CAAiBC,iBAAiB,CAAjBA,KAAiB,CAAjBA,CAA/C,MAA8B,CAA9B;AACA,MAAMP,WAAW,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,CAAA,EAAC;AAAA,WAAIU,CAAC,CAADA,MAAAA,GAAJ,SAAA;AAAX,GAAA,EAAA,GAAA,CAAyCT,aAAa,CAA1E,CAA0E,CAAtD,CAApB;AACAD,EAAAA,WAAW,CAAXA,OAAAA,CAAAA,CAAAA;AAEA,SAAO;AACLL,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAN,qBAAA;AAA+BC,MAAAA,IAAI,EAAEjB;AAArC,KADN;AAELmB,IAAAA,WAAW,EAAE;AAACH,MAAAA,KAAK,EAAE,IAAA,WAAA,CAAR,WAAQ,CAAR;AAAsCC,MAAAA,IAAI,EAAE;AAA5C;AAFR,GAAP;AAID;;AAED,SAAA,iBAAA,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAAA,YAAA,EAAkE;AAChE,MAAMkB,SAAS,GAAGxC,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAlB,YAAkBA,CAAlB;AACAC,EAAAA,MAAM,IAANA,CAAAA;AAEA,MAAMwC,QAAQ,GAAd,EAAA;AACA,MAAMC,iBAAiB,GAAvB,EAAA;;AACA,OAAK,IAAItB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,SAAA,EAA+BA,CAA/B,EAAA,EAAoC;AAElC,QAAMuB,mBAAmB,GAAG3C,IAAI,CAAJA,QAAAA,CAAAA,MAAAA,MAA5B,CAAA;AACAC,IAAAA,MAAM;AAGNiB,IAAAA,MAAM,CACJlB,IAAI,CAAJA,SAAAA,CAAAA,MAAAA,EAAAA,mBAAAA,IAAAA,IAAAA,KADI,CAAA,EAANkB,sDAAM,CAANA;AAIAjB,IAAAA,MAAM,IAANA,CAAAA;AAEA,QAAM4B,MAAM,GAAGlB,YAAY,CAAA,IAAA,EAAA,MAAA,EAAA,SAAA,EAA3B,mBAA2B,CAA3B;AAZkC,QAa3BQ,SAb2B,GAaWU,MAbX,CAAA,SAAA;AAAA,QAahBI,wBAbgB,GAaWJ,MAbX,CAAA,uBAAA;AAclC5B,IAAAA,MAAM,GAAG4B,MAAM,CAAf5B,MAAAA;AACAwC,IAAAA,QAAQ,CAARA,IAAAA,CAActB,SAAS,CAAvBsB,KAAAA;AACAC,IAAAA,iBAAiB,CAAjBA,IAAAA,CAAuBT,wBAAuB,CAA9CS,KAAAA;AACD;;AAED,MAAMZ,qBAAqB,GAAG,IAAA,YAAA,CAAiBC,iBAAiB,CAAjBA,QAAiB,CAAjBA,CAA/C,MAA8B,CAA9B;AACA,MAAMC,cAAc,GAAG,QAAQ,CAAR,GAAA,CAAa,UAAA,CAAA,EAAC;AAAA,WAAIY,CAAC,CAADA,MAAAA,GAAJ,SAAA;AAAd,GAAA,EAAA,GAAA,CAA4CnB,aAAa,CAAhF,CAAgF,CAAzD,CAAvB;AACAO,EAAAA,cAAc,CAAdA,OAAAA,CAAAA,CAAAA;AAGA,MAAMC,uBAAuB,GAAG,CAAhC,CAAgC,CAAhC;;AACA,OAAA,IAAA,EAAA,GAAA,CAAA,EAAA,kBAAA,GAAA,iBAAA,EAAA,EAAA,GAAA,kBAAA,CAAA,MAAA,EAAA,EAAA,EAAA,EAAkD;AAA7C,QAAMY,gBAAgB,GAAA,kBAAA,CAAtB,EAAsB,CAAtB;AACHZ,IAAAA,uBAAuB,CAAvBA,IAAAA,CAAAA,KAAAA,CAAAA,uBAAAA,EAAuB,kBAAA,CAClB,gBAAgB,CAAhB,MAAA,CACO,UAAA,CAAA,EAAC;AAAA,aAAIa,CAAC,GAAL,CAAA;AADR,KAAA,EAAA,GAAA,CAEI,UAAA,CAAA,EAAC;AAAA,aAAIA,CAAC,GAAGb,uBAAuB,CAACA,uBAAuB,CAAvBA,MAAAA,GAAhC,CAA+B,CAA/B;AAHVA,KACK,CADkB,CAAvBA;AAKD;;AAED,SAAO;AACLd,IAAAA,SAAS,EAAE;AAACE,MAAAA,KAAK,EAAN,qBAAA;AAA+BC,MAAAA,IAAI,EAAEjB;AAArC,KADN;AAEL2B,IAAAA,cAAc,EAAE;AAACX,MAAAA,KAAK,EAAE,IAAA,WAAA,CAAR,cAAQ,CAAR;AAAyCC,MAAAA,IAAI,EAAE;AAA/C,KAFX;AAGLW,IAAAA,uBAAuB,EAAE;AAACZ,MAAAA,KAAK,EAAE,IAAA,WAAA,CAAR,uBAAQ,CAAR;AAAkDC,MAAAA,IAAI,EAAE;AAAxD;AAHpB,GAAP;AAKD;;AAID,SAAA,iBAAA,CAAA,MAAA,EAAmC;AACjC,MAAIyB,UAAU,GAAd,CAAA;;AACA,OAAK,IAAI3B,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG4B,MAAM,CAA1B,MAAA,EAAmC,EAAnC,CAAA,EAAwC;AACtCD,IAAAA,UAAU,IAAIC,MAAM,CAANA,CAAM,CAANA,CAAdD,UAAAA;AACD;;AACD,MAAME,MAAM,GAAG,IAAA,UAAA,CAAf,UAAe,CAAf;AAEA,MAAIC,UAAU,GAAd,CAAA;;AACA,OAAK,IAAI9B,GAAC,GAAV,CAAA,EAAgBA,GAAC,GAAG4B,MAAM,CAA1B,MAAA,EAAmC,EAAnC,GAAA,EAAwC;AACtC,QAAMG,IAAI,GAAG,IAAA,UAAA,CAAeH,MAAM,CAANA,GAAM,CAANA,CAA5B,MAAa,CAAb;AACAD,IAAAA,UAAU,GAAGI,IAAI,CAAjBJ,MAAAA;;AACA,SAAK,IAAIK,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,UAAA,EAAgC,EAAhC,CAAA,EAAqC;AACnCH,MAAAA,MAAM,CAACC,UAAPD,EAAM,CAANA,GAAuBE,IAAI,CAA3BF,CAA2B,CAA3BA;AACD;AACF;;AACD,SAAA,MAAA;AACD;;AAED,SAAA,MAAA,CAAA,SAAA,EAAA,OAAA,EAAoC;AAClC,MAAI,CAAJ,SAAA,EAAgB;AACd,UAAM,IAAA,KAAA,CAAA,oCAAA,MAAA,CAAN,OAAM,CAAA,CAAN;AACD;AACF","sourcesContent":["const NUM_DIMENSIONS = {\n  0: 2, // 2D\n  1: 3, // 3D (Z)\n  2: 3, // 3D (M)\n  3: 4 // 4D (ZM)\n};\n\nexport default function parseWKB(buffer) {\n  const view = new DataView(buffer);\n  let offset = 0;\n\n  // Check endianness of data\n  const littleEndian = view.getUint8(offset) === 1;\n  offset++;\n\n  // 4-digit code representing dimension and type of geometry\n  const geometryCode = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  const geometryType = geometryCode % 1000;\n  const dimension = NUM_DIMENSIONS[(geometryCode - geometryType) / 1000];\n\n  switch (geometryType) {\n    case 1:\n      const point = parsePoint(view, offset, dimension, littleEndian);\n      delete point.offset;\n      point.type = 'Point';\n      return point;\n    case 2:\n      const line = parseLineString(view, offset, dimension, littleEndian);\n      delete line.offset;\n      line.type = 'LineString';\n      return line;\n    case 3:\n      const polygon = parsePolygon(view, offset, dimension, littleEndian);\n      delete polygon.offset;\n      polygon.type = 'Polygon';\n      return polygon;\n    case 4:\n      const multiPoint = parseMultiPoint(view, offset, dimension, littleEndian);\n      multiPoint.type = 'Point';\n      return multiPoint;\n    case 5:\n      const multiLine = parseMultiLineString(view, offset, dimension, littleEndian);\n      multiLine.type = 'LineString';\n      return multiLine;\n    case 6:\n      const multiPolygon = parseMultiPolygon(view, offset, dimension, littleEndian);\n      multiPolygon.type = 'Polygon';\n      return multiPolygon;\n    // case 7:\n    // TODO: handle GeometryCollections\n    // return parseGeometryCollection(view, offset, dimension, littleEndian);\n    default:\n      assert(false, `Unsupported geometry type: ${geometryType}`);\n  }\n\n  return null;\n}\n\n// Primitives; parse point and linear ring\nfunction parsePoint(view, offset, dimension, littleEndian) {\n  const positions = new Float64Array(dimension);\n  for (let i = 0; i < dimension; i++) {\n    positions[i] = view.getFloat64(offset, littleEndian);\n    offset += 8;\n  }\n\n  return {positions: {value: positions, size: dimension}, offset};\n}\n\nfunction parseLineString(view, offset, dimension, littleEndian) {\n  const nPoints = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  // Instantiate array\n  const positions = new Float64Array(nPoints * dimension);\n  for (let i = 0; i < nPoints * dimension; i++) {\n    positions[i] = view.getFloat64(offset, littleEndian);\n    offset += 8;\n  }\n\n  const pathIndices = [0];\n  if (nPoints > 0) {\n    pathIndices.push(nPoints);\n  }\n\n  return {\n    positions: {value: positions, size: dimension},\n    pathIndices: {value: new Uint16Array(pathIndices), size: 1},\n    offset\n  };\n}\n\n// https://stackoverflow.com/a/55261098\nconst cumulativeSum = sum => value => (sum += value);\n\nfunction parsePolygon(view, offset, dimension, littleEndian) {\n  const nRings = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  const rings = [];\n  for (let i = 0; i < nRings; i++) {\n    const parsed = parseLineString(view, offset, dimension, littleEndian);\n    const {positions} = parsed;\n    offset = parsed.offset;\n    rings.push(positions.value);\n  }\n\n  const concatenatedPositions = new Float64Array(concatTypedArrays(rings).buffer);\n  const polygonIndices = [0];\n  if (concatenatedPositions.length > 0) {\n    polygonIndices.push(concatenatedPositions.length / dimension);\n  }\n  const primitivePolygonIndices = rings.map(l => l.length / dimension).map(cumulativeSum(0));\n  primitivePolygonIndices.unshift(0);\n\n  return {\n    positions: {value: concatenatedPositions, size: dimension},\n    polygonIndices: {\n      value: new Uint16Array(polygonIndices),\n      size: 1\n    },\n    primitivePolygonIndices: {value: new Uint16Array(primitivePolygonIndices), size: 1},\n    offset\n  };\n}\n\nfunction parseMultiPoint(view, offset, dimension, littleEndian) {\n  const nPoints = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  const points = [];\n  for (let i = 0; i < nPoints; i++) {\n    // Byte order for point\n    const littleEndianPoint = view.getUint8(offset) === 1;\n    offset++;\n\n    // Assert point type\n    assert(\n      view.getUint32(offset, littleEndianPoint) % 1000 === 1,\n      'Inner geometries of MultiPoint not of type Point'\n    );\n    offset += 4;\n\n    const parsed = parsePoint(view, offset, dimension, littleEndianPoint);\n    const {positions} = parsed;\n    offset = parsed.offset;\n    points.push(positions.value);\n  }\n\n  const concatenatedPositions = new Float64Array(concatTypedArrays(points).buffer);\n\n  return {\n    positions: {value: concatenatedPositions, size: dimension}\n  };\n}\n\nfunction parseMultiLineString(view, offset, dimension, littleEndian) {\n  const nLines = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  const lines = [];\n  for (let i = 0; i < nLines; i++) {\n    // Byte order for line\n    const littleEndianLine = view.getUint8(offset) === 1;\n    offset++;\n\n    // Assert type LineString\n    assert(\n      view.getUint32(offset, littleEndianLine) % 1000 === 2,\n      'Inner geometries of MultiLineString not of type LineString'\n    );\n    offset += 4;\n\n    const parsed = parseLineString(view, offset, dimension, littleEndianLine);\n    const {positions} = parsed;\n    offset = parsed.offset;\n    lines.push(positions.value);\n  }\n\n  const concatenatedPositions = new Float64Array(concatTypedArrays(lines).buffer);\n  const pathIndices = lines.map(l => l.length / dimension).map(cumulativeSum(0));\n  pathIndices.unshift(0);\n\n  return {\n    positions: {value: concatenatedPositions, size: dimension},\n    pathIndices: {value: new Uint16Array(pathIndices), size: 1}\n  };\n}\n\nfunction parseMultiPolygon(view, offset, dimension, littleEndian) {\n  const nPolygons = view.getUint32(offset, littleEndian);\n  offset += 4;\n\n  const polygons = [];\n  const primitivePolygons = [];\n  for (let i = 0; i < nPolygons; i++) {\n    // Byte order for polygon\n    const littleEndianPolygon = view.getUint8(offset) === 1;\n    offset++;\n\n    // Assert type Polygon\n    assert(\n      view.getUint32(offset, littleEndianPolygon) % 1000 === 3,\n      'Inner geometries of MultiPolygon not of type Polygon'\n    );\n    offset += 4;\n\n    const parsed = parsePolygon(view, offset, dimension, littleEndianPolygon);\n    const {positions, primitivePolygonIndices} = parsed;\n    offset = parsed.offset;\n    polygons.push(positions.value);\n    primitivePolygons.push(primitivePolygonIndices.value);\n  }\n\n  const concatenatedPositions = new Float64Array(concatTypedArrays(polygons).buffer);\n  const polygonIndices = polygons.map(p => p.length / dimension).map(cumulativeSum(0));\n  polygonIndices.unshift(0);\n\n  // Combine primitivePolygonIndices from each individual polygon\n  const primitivePolygonIndices = [0];\n  for (const primitivePolygon of primitivePolygons) {\n    primitivePolygonIndices.push(\n      ...primitivePolygon\n        .filter(x => x > 0)\n        .map(x => x + primitivePolygonIndices[primitivePolygonIndices.length - 1])\n    );\n  }\n\n  return {\n    positions: {value: concatenatedPositions, size: dimension},\n    polygonIndices: {value: new Uint16Array(polygonIndices), size: 1},\n    primitivePolygonIndices: {value: new Uint16Array(primitivePolygonIndices), size: 1}\n  };\n}\n\n// TODO: remove copy; import from typed-array-utils\n// modules/math/src/geometry/typed-arrays/typed-array-utils.js\nfunction concatTypedArrays(arrays) {\n  let byteLength = 0;\n  for (let i = 0; i < arrays.length; ++i) {\n    byteLength += arrays[i].byteLength;\n  }\n  const buffer = new Uint8Array(byteLength);\n\n  let byteOffset = 0;\n  for (let i = 0; i < arrays.length; ++i) {\n    const data = new Uint8Array(arrays[i].buffer);\n    byteLength = data.length;\n    for (let j = 0; j < byteLength; ++j) {\n      buffer[byteOffset++] = data[j];\n    }\n  }\n  return buffer;\n}\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(`Error parsing Well-Known Binary. ${message}`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}