{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toGeoJson = toGeoJson;\nexports.toKml = toKml;\nexports.toWkt = toWkt;\nexports.toStats = toStats;\n\nvar _tokml = _interopRequireDefault(require(\"@maphubs/tokml\"));\n\nvar _wellknown = require(\"wellknown\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction toGeoJson(geoJson, filename) {\n  return {\n    data: JSON.stringify(geoJson, null, 2),\n    filename: \"\".concat(filename, \".geojson\"),\n    mimetype: 'application/json'\n  };\n}\n\nfunction toKml(geoJson, filename) {\n  // For some reason, google maps doesn't surface id unless it is in the properties\n  // So, put it also in properties\n  if (geoJson.type === 'FeatureCollection') {\n    geoJson.features.forEach(function (f) {\n      f.properties = f.properties || {};\n    });\n  }\n\n  var kmlString = (0, _tokml[\"default\"])(geoJson); // kmlString = addIdToKml(geoJson, kmlString);\n\n  return {\n    data: kmlString,\n    filename: \"\".concat(filename, \".kml\"),\n    mimetype: 'application/xml'\n  };\n}\n\nfunction toWkt(geoJson, filename) {\n  var wkt = '';\n\n  if (geoJson.type === 'Feature') {\n    // @ts-ignore\n    wkt = (0, _wellknown.stringify)(geoJson);\n  } else {\n    // feature collection\n    wkt = '';\n\n    var _iterator = _createForOfIteratorHelper(geoJson.features),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var feature = _step.value; // @ts-ignore\n\n        wkt += \"\".concat((0, _wellknown.stringify)(feature), \"\\n\");\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (wkt.length > 0) {\n      wkt = wkt.substring(0, wkt.length - 1);\n    }\n  }\n\n  return {\n    data: wkt,\n    filename: \"\".concat(filename, \".wkt\"),\n    mimetype: 'text/plain'\n  };\n}\n\nfunction toStats(geoJson, filename) {\n  var pointCount = 0;\n  var ringCount = 0;\n  var polygonCount = 0;\n  var featureCount = 0;\n\n  if (geoJson.type === 'Feature') {\n    var polygonStats = getPolygonalStats(geoJson.geometry);\n    pointCount = polygonStats.pointCount;\n    ringCount = polygonStats.ringCount;\n    polygonCount = polygonStats.polygonCount;\n    featureCount = 1;\n  } else {\n    var _iterator2 = _createForOfIteratorHelper(geoJson.features),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var feature = _step2.value;\n\n        var _polygonStats = getPolygonalStats(feature.geometry);\n\n        pointCount += _polygonStats.pointCount;\n        ringCount += _polygonStats.ringCount;\n        polygonCount += _polygonStats.polygonCount;\n        featureCount++;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  var stats = \"Features: \".concat(featureCount, \"\\nPolygons: \").concat(polygonCount, \"\\nRings: \").concat(ringCount, \"\\nPoints: \").concat(pointCount);\n  return {\n    data: stats,\n    filename: \"\".concat(filename, \".txt\"),\n    mimetype: 'text/plain'\n  };\n}\n\nfunction getPolygonalStats(geometry) {\n  if (geometry.type !== 'Polygon' && geometry.type !== 'MultiPolygon') {\n    return {\n      pointCount: -1,\n      ringCount: -1,\n      polygonCount: -1\n    };\n  }\n\n  var polygonal = geometry;\n  var pointCount = 0;\n  var ringCount = 0;\n  var polygonCount = 0;\n\n  var _iterator3 = _createForOfIteratorHelper(polygonal.coordinates),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var ringOrPolygon = _step3.value;\n\n      if (geometry.type === 'Polygon') {\n        polygonCount = 1;\n        ringCount++;\n        pointCount += ringOrPolygon.length;\n      } else if (geometry.type === 'MultiPolygon') {\n        polygonCount++;\n\n        var _iterator4 = _createForOfIteratorHelper(ringOrPolygon),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var ring = _step4.value;\n            ringCount++;\n            pointCount += ring.length;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return {\n    pointCount: pointCount,\n    ringCount: ringCount,\n    polygonCount: polygonCount\n  };\n}","map":{"version":3,"sources":["../../src/lib/exporter.ts"],"names":["data","JSON","filename","mimetype","geoJson","f","kmlString","wkt","feature","pointCount","ringCount","polygonCount","featureCount","polygonStats","getPolygonalStats","stats","geometry","polygonal","ringOrPolygon","ring"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\nimport tokml from '@maphubs/tokml';\nimport { stringify as stringifyWkt } from 'wellknown';\n// @ts-ignore\nimport { AnyGeoJson, Geometry, PolygonalGeometry } from '@nebula.gl/edit-modes';\n\nexport type ExportParameters = {\n  data: string;\n  filename: string;\n  mimetype: string;\n};\n\nexport function toGeoJson(geoJson: AnyGeoJson, filename: string): ExportParameters {\n  return {\n    data: JSON.stringify(geoJson, null, 2),\n    filename: `${filename}.geojson`,\n    mimetype: 'application/json',\n  };\n}\n\nexport function toKml(geoJson: AnyGeoJson, filename: string): ExportParameters {\n  // For some reason, google maps doesn't surface id unless it is in the properties\n  // So, put it also in properties\n  if (geoJson.type === 'FeatureCollection') {\n    geoJson.features.forEach((f) => {\n      f.properties = f.properties || {};\n    });\n  }\n\n  const kmlString = tokml(geoJson);\n\n  // kmlString = addIdToKml(geoJson, kmlString);\n\n  return {\n    data: kmlString,\n    filename: `${filename}.kml`,\n    mimetype: 'application/xml',\n  };\n}\n\nexport function toWkt(geoJson: AnyGeoJson, filename: string): ExportParameters {\n  let wkt = '';\n  if (geoJson.type === 'Feature') {\n    // @ts-ignore\n    wkt = stringifyWkt(geoJson);\n  } else {\n    // feature collection\n    wkt = '';\n    for (const feature of geoJson.features) {\n      // @ts-ignore\n      wkt += `${stringifyWkt(feature)}\\n`;\n    }\n    if (wkt.length > 0) {\n      wkt = wkt.substring(0, wkt.length - 1);\n    }\n  }\n\n  return {\n    data: wkt,\n    filename: `${filename}.wkt`,\n    mimetype: 'text/plain',\n  };\n}\n\nexport function toStats(geoJson: AnyGeoJson, filename: string): ExportParameters {\n  let pointCount = 0;\n  let ringCount = 0;\n  let polygonCount = 0;\n  let featureCount = 0;\n\n  if (geoJson.type === 'Feature') {\n    const polygonStats = getPolygonalStats(geoJson.geometry);\n    ({ pointCount, ringCount, polygonCount } = polygonStats);\n    featureCount = 1;\n  } else {\n    for (const feature of geoJson.features) {\n      const polygonStats = getPolygonalStats(feature.geometry);\n      pointCount += polygonStats.pointCount;\n      ringCount += polygonStats.ringCount;\n      polygonCount += polygonStats.polygonCount;\n      featureCount++;\n    }\n  }\n\n  const stats = `Features: ${featureCount}\nPolygons: ${polygonCount}\nRings: ${ringCount}\nPoints: ${pointCount}`;\n\n  return {\n    data: stats,\n    filename: `${filename}.txt`,\n    mimetype: 'text/plain',\n  };\n}\n\nfunction getPolygonalStats(geometry: Geometry) {\n  if (geometry.type !== 'Polygon' && geometry.type !== 'MultiPolygon') {\n    return {\n      pointCount: -1,\n      ringCount: -1,\n      polygonCount: -1,\n    };\n  }\n\n  const polygonal: PolygonalGeometry = geometry;\n\n  let pointCount = 0;\n  let ringCount = 0;\n  let polygonCount = 0;\n  for (const ringOrPolygon of polygonal.coordinates) {\n    if (geometry.type === 'Polygon') {\n      polygonCount = 1;\n      ringCount++;\n      pointCount += ringOrPolygon.length;\n    } else if (geometry.type === 'MultiPolygon') {\n      polygonCount++;\n      for (const ring of ringOrPolygon) {\n        ringCount++;\n        pointCount += ring.length;\n      }\n    }\n  }\n  return {\n    pointCount,\n    ringCount,\n    polygonCount,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}