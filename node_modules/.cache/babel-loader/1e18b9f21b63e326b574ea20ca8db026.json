{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { LayerExtension } from '@deck.gl/core';\nimport { shaderModule, shaderModule64 } from './shader-module';\nimport * as aggregator from './aggregator';\nimport { readPixelsToArray, clear } from '@luma.gl/core';\nvar defaultProps = {\n  getFilterValue: {\n    type: 'accessor',\n    value: 0\n  },\n  onFilteredItemsChange: {\n    type: 'function',\n    value: null,\n    compare: false\n  },\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterTransformSize: true,\n  filterTransformColor: true\n};\nvar DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\nvar DataFilterExtension = function (_LayerExtension) {\n  _inherits(DataFilterExtension, _LayerExtension);\n\n  var _super = _createSuper(DataFilterExtension);\n\n  function DataFilterExtension() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$filterSize = _ref.filterSize,\n        filterSize = _ref$filterSize === void 0 ? 1 : _ref$filterSize,\n        _ref$fp = _ref.fp64,\n        fp64 = _ref$fp === void 0 ? false : _ref$fp,\n        _ref$countItems = _ref.countItems,\n        countItems = _ref$countItems === void 0 ? false : _ref$countItems;\n\n    _classCallCheck(this, DataFilterExtension);\n\n    if (!DATA_TYPE_FROM_SIZE[filterSize]) {\n      throw new Error('filterSize out of range');\n    }\n\n    return _super.call(this, {\n      filterSize: filterSize,\n      fp64: fp64,\n      countItems: countItems\n    });\n  }\n\n  _createClass(DataFilterExtension, [{\n    key: \"getShaders\",\n    value: function getShaders(extension) {\n      var _extension$opts = extension.opts,\n          filterSize = _extension$opts.filterSize,\n          fp64 = _extension$opts.fp64;\n      return {\n        modules: [fp64 ? shaderModule64 : shaderModule],\n        defines: {\n          DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],\n          DATAFILTER_DOUBLE: Boolean(fp64)\n        }\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState(context, extension) {\n      var attributeManager = this.getAttributeManager();\n\n      if (attributeManager) {\n        attributeManager.add({\n          filterValues: {\n            size: extension.opts.filterSize,\n            type: extension.opts.fp64 ? 5130 : 5126,\n            accessor: 'getFilterValue',\n            shaderAttributes: {\n              filterValues: {\n                divisor: 0\n              },\n              instanceFilterValues: {\n                divisor: 1\n              }\n            }\n          }\n        });\n      }\n\n      var gl = this.context.gl;\n\n      if (attributeManager && extension.opts.countItems) {\n        var useFloatTarget = aggregator.supportsFloatTarget(gl);\n        attributeManager.add({\n          filterIndices: {\n            size: useFloatTarget ? 1 : 2,\n            vertexOffset: 1,\n            type: 5121,\n            normalized: true,\n            accessor: function accessor(object, _ref2) {\n              var index = _ref2.index;\n              var i = object && object.__source ? object.__source.index : index;\n              return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n            },\n            shaderAttributes: {\n              filterPrevIndices: {\n                vertexOffset: 0\n              },\n              filterIndices: {\n                vertexOffset: 1\n              }\n            }\n          }\n        });\n        var filterFBO = aggregator.getFramebuffer(gl, useFloatTarget);\n        var filterModel = aggregator.getModel(gl, extension.getShaders(extension), useFloatTarget);\n        this.setState({\n          filterFBO: filterFBO,\n          filterModel: filterModel\n        });\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref3) {\n      var props = _ref3.props,\n          oldProps = _ref3.oldProps;\n\n      if (this.state.filterModel) {\n        var attributeManager = this.getAttributeManager();\n        var filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange;\n\n        if (filterNeedsUpdate) {\n          this.setState({\n            filterNeedsUpdate: filterNeedsUpdate\n          });\n        }\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(params, extension) {\n      var _this$state = this.state,\n          filterFBO = _this$state.filterFBO,\n          filterModel = _this$state.filterModel,\n          filterNeedsUpdate = _this$state.filterNeedsUpdate;\n      var onFilteredItemsChange = this.props.onFilteredItemsChange;\n\n      if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n        var _this$getAttributeMan = this.getAttributeManager(),\n            _this$getAttributeMan2 = _this$getAttributeMan.attributes,\n            filterValues = _this$getAttributeMan2.filterValues,\n            filterIndices = _this$getAttributeMan2.filterIndices;\n\n        filterModel.setVertexCount(this.getNumInstances());\n        var gl = this.context.gl;\n        clear(gl, {\n          framebuffer: filterFBO,\n          color: [0, 0, 0, 0]\n        });\n        filterModel.updateModuleSettings(params.moduleParameters).setAttributes(_objectSpread(_objectSpread({}, filterValues.getShaderAttributes()), filterIndices && filterIndices.getShaderAttributes())).draw({\n          framebuffer: filterFBO,\n          parameters: _objectSpread(_objectSpread({}, aggregator.parameters), {}, {\n            viewport: [0, 0, filterFBO.width, filterFBO.height]\n          })\n        });\n        var color = readPixelsToArray(filterFBO);\n        var count = 0;\n\n        for (var i = 0; i < color.length; i++) {\n          count += color[i];\n        }\n\n        onFilteredItemsChange({\n          id: this.id,\n          count: count\n        });\n        this.state.filterNeedsUpdate = false;\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      var _this$state2 = this.state,\n          filterFBO = _this$state2.filterFBO,\n          filterModel = _this$state2.filterModel;\n\n      if (filterFBO) {\n        filterFBO.color[\"delete\"]();\n        filterFBO[\"delete\"]();\n        filterModel[\"delete\"]();\n      }\n    }\n  }]);\n\n  return DataFilterExtension;\n}(LayerExtension);\n\nexport { DataFilterExtension as default };\nDataFilterExtension.extensionName = 'DataFilterExtension';\nDataFilterExtension.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/data-filter/data-filter.js"],"names":["defaultProps","getFilterValue","type","value","onFilteredItemsChange","compare","filterEnabled","filterRange","filterSoftRange","filterTransformSize","filterTransformColor","DATA_TYPE_FROM_SIZE","DataFilterExtension","LayerExtension","filterSize","fp64","countItems","extension","modules","defines","DATAFILTER_TYPE","DATAFILTER_DOUBLE","Boolean","context","attributeManager","filterValues","size","accessor","shaderAttributes","divisor","instanceFilterValues","gl","useFloatTarget","aggregator","filterIndices","vertexOffset","normalized","index","i","object","Math","filterPrevIndices","filterFBO","filterModel","props","oldProps","filterNeedsUpdate","params","clear","framebuffer","color","parameters","viewport","readPixelsToArray","count","id"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension} from '@deck.gl/core';\nimport {shaderModule, shaderModule64} from './shader-module';\nimport * as aggregator from './aggregator';\nimport {readPixelsToArray, clear} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nconst defaultProps = {\n  getFilterValue: {type: 'accessor', value: 0},\n  onFilteredItemsChange: {type: 'function', value: null, compare: false},\n\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterTransformSize: true,\n  filterTransformColor: true\n};\n\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\nexport default class DataFilterExtension extends LayerExtension {\n  constructor({filterSize = 1, fp64 = false, countItems = false} = {}) {\n    if (!DATA_TYPE_FROM_SIZE[filterSize]) {\n      throw new Error('filterSize out of range');\n    }\n\n    super({filterSize, fp64, countItems});\n  }\n\n  getShaders(extension) {\n    const {filterSize, fp64} = extension.opts;\n\n    return {\n      modules: [fp64 ? shaderModule64 : shaderModule],\n      defines: {\n        DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],\n        DATAFILTER_DOUBLE: Boolean(fp64)\n      }\n    };\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.add({\n        filterValues: {\n          size: extension.opts.filterSize,\n          type: extension.opts.fp64 ? GL.DOUBLE : GL.FLOAT,\n          accessor: 'getFilterValue',\n          shaderAttributes: {\n            filterValues: {\n              divisor: 0\n            },\n            instanceFilterValues: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    const {gl} = this.context;\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(gl);\n      // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n      // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n      // so that we only write one count cross multiple vertices of the same object\n      attributeManager.add({\n        filterIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: GL.UNSIGNED_BYTE,\n          normalized: true,\n          accessor: (object, {index}) => {\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n\n      const filterFBO = aggregator.getFramebuffer(gl, useFloatTarget);\n      const filterModel = aggregator.getModel(gl, extension.getShaders(extension), useFloatTarget);\n      this.setState({filterFBO, filterModel});\n    }\n  }\n\n  updateState({props, oldProps}) {\n    if (this.state.filterModel) {\n      const attributeManager = this.getAttributeManager();\n      const filterNeedsUpdate =\n        attributeManager.attributes.filterValues.needsUpdate() ||\n        props.filterEnabled !== oldProps.filterEnabled ||\n        props.filterRange !== oldProps.filterRange ||\n        props.filterSoftRange !== oldProps.filterSoftRange;\n      if (filterNeedsUpdate) {\n        this.setState({filterNeedsUpdate});\n      }\n    }\n  }\n\n  draw(params, extension) {\n    const {filterFBO, filterModel, filterNeedsUpdate} = this.state;\n    const {onFilteredItemsChange} = this.props;\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const {\n        attributes: {filterValues, filterIndices}\n      } = this.getAttributeManager();\n      filterModel.setVertexCount(this.getNumInstances());\n\n      const {gl} = this.context;\n      clear(gl, {framebuffer: filterFBO, color: [0, 0, 0, 0]});\n\n      filterModel\n        .updateModuleSettings(params.moduleParameters)\n        .setAttributes({\n          ...filterValues.getShaderAttributes(),\n          ...(filterIndices && filterIndices.getShaderAttributes())\n        })\n        .draw({\n          framebuffer: filterFBO,\n          parameters: {\n            ...aggregator.parameters,\n            viewport: [0, 0, filterFBO.width, filterFBO.height]\n          }\n        });\n      const color = readPixelsToArray(filterFBO);\n      let count = 0;\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n      onFilteredItemsChange({id: this.id, count});\n\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n\n  finalizeState() {\n    const {filterFBO, filterModel} = this.state;\n    if (filterFBO) {\n      filterFBO.color.delete();\n      filterFBO.delete();\n      filterModel.delete();\n    }\n  }\n}\n\nDataFilterExtension.extensionName = 'DataFilterExtension';\nDataFilterExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}