{"ast":null,"code":"var numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;\nvar tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\nexport default function parseWKT(input) {\n  var parts = input.split(';');\n\n  var _ = parts.pop();\n\n  var srid = (parts.shift() || '').split('=').pop();\n  var i = 0;\n\n  function $(re) {\n    var match = _.substring(i).match(re);\n\n    if (!match) return null;else {\n      i += match[0].length;\n      return match[0];\n    }\n  }\n\n  function crs(obj) {\n    if (obj && srid.match(/\\d+/)) {\n      obj.crs = {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:EPSG::' + srid\n        }\n      };\n    }\n\n    return obj;\n  }\n\n  function white() {\n    $(/^\\s*/);\n  }\n\n  function multicoords() {\n    white();\n    var depth = 0;\n    var rings = [];\n    var stack = [rings];\n    var pointer = rings;\n    var elem;\n\n    while (elem = $(/^(\\()/) || $(/^(\\))/) || $(/^(,)/) || $(tuples)) {\n      if (elem === '(') {\n        stack.push(pointer);\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n        depth++;\n      } else if (elem === ')') {\n        if (pointer.length === 0) return null;\n        pointer = stack.pop();\n        if (!pointer) return null;\n        depth--;\n        if (depth === 0) break;\n      } else if (elem === ',') {\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n      } else if (!elem.split(/\\s/g).some(isNaN)) {\n        Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n      } else {\n        return null;\n      }\n\n      white();\n    }\n\n    if (depth !== 0) return null;\n    return rings;\n  }\n\n  function coords() {\n    var list = [];\n    var item;\n    var pt;\n\n    while (pt = $(tuples) || $(/^(,)/)) {\n      if (pt === ',') {\n        list.push(item);\n        item = [];\n      } else if (!pt.split(/\\s/g).some(isNaN)) {\n        if (!item) item = [];\n        Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n      }\n\n      white();\n    }\n\n    if (item) list.push(item);else return null;\n    return list.length ? list : null;\n  }\n\n  function point() {\n    if (!$(/^(point(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    white();\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'Point',\n      coordinates: c[0]\n    };\n  }\n\n  function multipoint() {\n    if (!$(/^(multipoint)/i)) return null;\n    white();\n\n    var newCoordsFormat = _.substring(_.indexOf('(') + 1, _.length - 1).replace(/\\(/g, '').replace(/\\)/g, '');\n\n    _ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiPoint',\n      coordinates: c\n    };\n  }\n\n  function multilinestring() {\n    if (!$(/^(multilinestring)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiLineString',\n      coordinates: c\n    };\n  }\n\n  function linestring() {\n    if (!$(/^(linestring(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'LineString',\n      coordinates: c\n    };\n  }\n\n  function polygon() {\n    if (!$(/^(polygon(\\sz)?)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'Polygon',\n      coordinates: c\n    };\n  }\n\n  function multipolygon() {\n    if (!$(/^(multipolygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'MultiPolygon',\n      coordinates: c\n    };\n  }\n\n  function geometrycollection() {\n    var geometries = [];\n    var geometry;\n    if (!$(/^(geometrycollection)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n\n    while (geometry = root()) {\n      geometries.push(geometry);\n      white();\n      $(/^(,)/);\n      white();\n    }\n\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'GeometryCollection',\n      geometries: geometries\n    };\n  }\n\n  function root() {\n    return point() || linestring() || polygon() || multipoint() || multilinestring() || multipolygon() || geometrycollection();\n  }\n\n  return crs(root());\n}","map":{"version":3,"sources":["../../../src/lib/parse-wkt.js"],"names":["numberRegexp","tuples","parts","input","_","srid","i","match","obj","type","properties","name","$","white","depth","rings","stack","pointer","elem","Array","list","pt","item","c","coords","coordinates","newCoordsFormat","multicoords","geometries","geometry","root","point","linestring","polygon","multipoint","multilinestring","multipolygon","geometrycollection","crs"],"mappings":"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","sourcesContent":["// Fork of https://github.com/mapbox/wellknown under ISC license (MIT/BSD-2-clause equivalent)\n/* eslint-disable */\n\nconst numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;\n// Matches sequences like '100 100' or '100 100 100'.\nconst tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\n\n/*\n  * Parse WKT and return GeoJSON.\n  *\n  * @param {string} _ A WKT geometry\n  * @return {?Object} A GeoJSON geometry object\n  */\nexport default function parseWKT(input) {\n  var parts = input.split(';');\n  var _ = parts.pop();\n  var srid = (parts.shift() || '').split('=').pop();\n\n  var i = 0;\n\n  function $(re) {\n    var match = _.substring(i).match(re);\n    if (!match) return null;\n    else {\n      i += match[0].length;\n      return match[0];\n    }\n  }\n\n  function crs(obj) {\n    if (obj && srid.match(/\\d+/)) {\n      obj.crs = {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:EPSG::' + srid\n        }\n      };\n    }\n\n    return obj;\n  }\n\n  function white() {\n    $(/^\\s*/);\n  }\n\n  function multicoords() {\n    white();\n    var depth = 0;\n    var rings = [];\n    var stack = [rings];\n    var pointer = rings;\n    var elem;\n\n    while ((elem = $(/^(\\()/) || $(/^(\\))/) || $(/^(,)/) || $(tuples))) {\n      if (elem === '(') {\n        stack.push(pointer);\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n        depth++;\n      } else if (elem === ')') {\n        // For the case: Polygon(), ...\n        if (pointer.length === 0) return null;\n\n        // @ts-ignore\n        pointer = stack.pop();\n        // the stack was empty, input was malformed\n        if (!pointer) return null;\n        depth--;\n        if (depth === 0) break;\n      } else if (elem === ',') {\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n      } else if (!elem.split(/\\s/g).some(isNaN)) {\n        Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n      } else {\n        return null;\n      }\n      white();\n    }\n\n    if (depth !== 0) return null;\n\n    return rings;\n  }\n\n  function coords() {\n    var list = [];\n    var item;\n    var pt;\n    while ((pt = $(tuples) || $(/^(,)/))) {\n      if (pt === ',') {\n        list.push(item);\n        item = [];\n      } else if (!pt.split(/\\s/g).some(isNaN)) {\n        if (!item) item = [];\n        Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n      }\n      white();\n    }\n\n    if (item) list.push(item);\n    else return null;\n\n    return list.length ? list : null;\n  }\n\n  function point() {\n    if (!$(/^(point(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    white();\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'Point',\n      coordinates: c[0]\n    };\n  }\n\n  function multipoint() {\n    if (!$(/^(multipoint)/i)) return null;\n    white();\n    var newCoordsFormat = _.substring(_.indexOf('(') + 1, _.length - 1)\n      .replace(/\\(/g, '')\n      .replace(/\\)/g, '');\n    _ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiPoint',\n      coordinates: c\n    };\n  }\n\n  function multilinestring() {\n    if (!$(/^(multilinestring)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiLineString',\n      coordinates: c\n    };\n  }\n\n  function linestring() {\n    if (!$(/^(linestring(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'LineString',\n      coordinates: c\n    };\n  }\n\n  function polygon() {\n    if (!$(/^(polygon(\\sz)?)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'Polygon',\n      coordinates: c\n    };\n  }\n\n  function multipolygon() {\n    if (!$(/^(multipolygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'MultiPolygon',\n      coordinates: c\n    };\n  }\n\n  function geometrycollection() {\n    var geometries = [];\n    var geometry;\n\n    if (!$(/^(geometrycollection)/i)) return null;\n    white();\n\n    if (!$(/^(\\()/)) return null;\n    while ((geometry = root())) {\n      geometries.push(geometry);\n      white();\n      $(/^(,)/);\n      white();\n    }\n    if (!$(/^(\\))/)) return null;\n\n    return {\n      type: 'GeometryCollection',\n      geometries: geometries\n    };\n  }\n\n  function root() {\n    return (\n      point() ||\n      linestring() ||\n      polygon() ||\n      multipoint() ||\n      multilinestring() ||\n      multipolygon() ||\n      geometrycollection()\n    );\n  }\n\n  return crs(root());\n}\n"]},"metadata":{},"sourceType":"module"}