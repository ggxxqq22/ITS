{"ast":null,"code":"import bearing from \"@turf/bearing\";\nimport distance from \"@turf/distance\";\nimport destination from \"@turf/destination\";\nimport lineIntersects from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\n\nfunction nearestPointOnLine(lines, pt, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var closestPt = point([Infinity, Infinity], {\n    dist: Infinity\n  });\n  var length = 0.0;\n  flattenEach(lines, function (line) {\n    var coords = getCoords(line);\n\n    for (var i = 0; i < coords.length - 1; i++) {\n      //start\n      var start = point(coords[i]);\n      start.properties.dist = distance(pt, start, options); //stop\n\n      var stop_1 = point(coords[i + 1]);\n      stop_1.properties.dist = distance(pt, stop_1, options); // sectionLength\n\n      var sectionLength = distance(start, stop_1, options); //perpendicular\n\n      var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n      var direction = bearing(start, stop_1);\n      var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n      var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n      var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n      var intersectPt = null;\n\n      if (intersect.features.length > 0) {\n        intersectPt = intersect.features[0];\n        intersectPt.properties.dist = distance(pt, intersectPt, options);\n        intersectPt.properties.location = length + distance(start, intersectPt, options);\n      }\n\n      if (start.properties.dist < closestPt.properties.dist) {\n        closestPt = start;\n        closestPt.properties.index = i;\n        closestPt.properties.location = length;\n      }\n\n      if (stop_1.properties.dist < closestPt.properties.dist) {\n        closestPt = stop_1;\n        closestPt.properties.index = i + 1;\n        closestPt.properties.location = length + sectionLength;\n      }\n\n      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = intersectPt;\n        closestPt.properties.index = i;\n      } // update length\n\n\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\n\nexport default nearestPointOnLine;","map":{"version":3,"sources":["/home/zhiguangda/ITS/deckgl/node_modules/@turf/nearest-point-on-line/dist/es/index.js"],"names":["bearing","distance","destination","lineIntersects","flattenEach","point","lineString","getCoords","nearestPointOnLine","lines","pt","options","closestPt","Infinity","dist","length","line","coords","i","start","properties","stop_1","sectionLength","heightDistance","Math","max","direction","perpendicularPt1","perpendicularPt2","intersect","geometry","coordinates","intersectPt","features","location","index"],"mappings":"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","sourcesContent":["import bearing from \"@turf/bearing\";\nimport distance from \"@turf/distance\";\nimport destination from \"@turf/destination\";\nimport lineIntersects from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    if (options === void 0) { options = {}; }\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity,\n    });\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, options);\n            //stop\n            var stop_1 = point(coords[i + 1]);\n            stop_1.properties.dist = distance(pt, stop_1, options);\n            // sectionLength\n            var sectionLength = distance(start, stop_1, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n            var direction = bearing(start, stop_1);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n            var intersect = lineIntersects(lineString([\n                perpendicularPt1.geometry.coordinates,\n                perpendicularPt2.geometry.coordinates,\n            ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\n                intersectPt.properties.location =\n                    length + distance(start, intersectPt, options);\n            }\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop_1.properties.dist < closestPt.properties.dist) {\n                closestPt = stop_1;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt &&\n                intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n    });\n    return closestPt;\n}\nexport default nearestPointOnLine;\n"]},"metadata":{},"sourceType":"module"}