{"ast":null,"code":"import React from 'react';\nimport * as d3 from \"d3\";\nexport const Marks = ({\n  data,\n  xScale,\n  xValue,\n  yScale,\n  innerHeight,\n  innerWidth,\n  margin,\n  keys,\n  start,\n  callback\n}) => {\n  const svg = d3.select('svg');\n  const xLength = 24;\n\n  const getTime = d => {\n    let date = new Date(d.date);\n    let hour = date.getHours();\n    let day = date.getDate();\n    return day + '/' + hour + ':00';\n  };\n\n  const delay = 1000;\n  let stack = d3.stack() //\n  .offset(d3.stackOffsetNone).order(d3.stackOrderNone);\n  var colorScale = d3.scaleOrdinal().range(d3.schemeCategory10);\n  var area = d3.area().x(d => xScale(xValue(d.data)) + margin.left).y0(d => yScale(d[0]) + margin.top).y1(d => yScale(d[1]) + margin.top).curve(d3.curveBasis);\n\n  if (data) {\n    data = data.slice(19, 139); // console.log(keys)\n\n    stack.keys(keys); // console.log('data',data);\n\n    let stacked = stack(data); // console.log('stack',stacked);\n\n    colorScale.domain(d3.range(keys.length));\n    xScale.domain(d3.extent(data, xValue)).range([0, innerWidth]);\n    yScale.domain([d3.min(stacked, function (series) {\n      return d3.min(series, function (d) {\n        return d[0];\n      });\n    }), d3.max(stacked, function (series) {\n      return d3.max(series, function (d) {\n        return d[1];\n      });\n    })]).range([innerHeight, 0]);\n    let rectData = []; //stack的数据结构：\n    //      //数组里面7个元素分别对应7个地点\n    //      //每个元素又是一个数组有24个元素分别对应24小时\n\n    /*       (7) [Array(24), Array(24), Array(24), Array(24), Array(24), Array(24), Array(24)]\n    0: Array(24)\n    0: (2) [0, 19.3671431509997, data: {…}, key: \"San Francisco\"]\n    1: (2) [0, 20.8082012083461, data: {…}, key: \"San Francisco\"]\n    2: (2) [0, 22.5238576663828, data: {…}, key: \"San Francisco\"]\n    3: (2) [0, 24.4214051463704, data: {…}, key: \"San Francisco\"]\n    4: (2) [0, 26.2049693716955, data: {…}, key: \"San Francisco\"]\n    5: (2) [0, 26.579802484894, data: {…}, key: \"San Francisco\"]\n    6: (2) [0, 26.5525094442272, data: {…}, key: \"San Francisco\"]\n    7: (2) [0, 23.9758724990251, data: {…}, key: \"San Francisco\"]\n    8: (2) [0, 20.7705334007582, data: {…}, key: \"San Francisco\"]\n    9: (2) [0, 19.5826361563267, data: {…}, key: \"San Francisco\"]\n    10: (2) [0, 18.7265399946616, data: {…}, key: \"San Francisco\"]\n    11: (2) [0, 18.2886029132647, data: {…}, key: \"San Francisco\"]\n    12: (2) [0, 17.4904771411586, data: {…}, key: \"San Francisco\"]\n    13: (2) [0, 17.1831430954037, data: {…}, key: \"San Francisco\"]\n    14: (2) [0, 17.2898856656444, data: {…}, key: \"San Francisco\"]\n    15: (2) [0, 17.8578100360021, data: {…}, key: \"San Francisco\"]\n    16: (2) [0, 18.1992192220978, data: {…}, key: \"San Francisco\"]\n    17: (2) [0, 18.13420905954, data: {…}, key: \"San Francisco\"]\n    18: (2) [0, 18.5888149684944, data: {…}, key: \"San Francisco\"]\n    19: (2) [0, 18.6733003026984, data: {…}, key: \"San Francisco\"]\n    20: (2) [0, 19.1600833190036, data: {…}, key: \"San Francisco\"]\n    21: (2) [0, 19.207095797011, data: {…}, key: \"San Francisco\"]\n    22: (2) [0, 18.9847082241235, data: {…}, key: \"San Francisco\"]\n    23: (2) [0, 19.4293802064908, data: {…}, key: \"San Francisco\"]\n    key: \"San Francisco\"\n    index: 0\n    length: 24\n    __proto__: Array(0)\n    1: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Bangalore\", index: 1]\n    2: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Boston\", index: 2]\n    3: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Geneva\", index: 3]\n    4: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Rio de Janeiro\", index: 4]\n    5: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Shanghai\", index: 5]\n    6: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Singapore\", index: 6]\n    length: 7\n    __proto__: Array(0)*/\n    //\n    //把 stack 再转换成按时间分组的数据，其实data就是按时间分组的，但是为了计算出堆叠出来的数据所以用的了stack\n\n    stacked.map(x => {\n      x.map((t, index) => {\n        t.key = x.key;\n\n        if (rectData[index] === undefined) {\n          rectData[index] = [];\n        }\n\n        rectData[index].push(t);\n      });\n    }); // console.log('rectData',rectData)\n\n    const group = svg.append('g');\n    const g2 = svg.append('g');\n    let count = 0;\n    let tmpData = [];\n    let groupCount = []; // tmpData.forEach(d=>{d.n=tmpData.indexOf(d)})\n\n    let testData = [];\n\n    function update() {\n      let popNum = 0;\n      groupCount.unshift(rectData[count].length);\n\n      if (groupCount.length > xLength) {\n        // console.log('24')\n        popNum = groupCount.pop();\n      } //tmpData 里面是每一个小矩形的数据(到目前为止所有插入的矩形)，如何对这些矩形计数呢从而和时间对应\n      //无论你有多少数据我都只取前24组时间内的数据//不对啊我这样做出来的效果并不是时间轴跟着动而是这个温度变成下一个时刻的温度这样的动态效果，最好试用的例子是不同年龄段的人随着时间变化的过程，并不是温度\n\n\n      rectData[count].forEach(d => {\n        d.count = count;\n        tmpData.unshift(d);\n      });\n      testData.unshift(rectData[count]); // console.log('testData',xValue(testData[0][0].data))\n\n      if (testData.length > xLength) testData.pop(); // console.log('testData',testData)\n\n      let g = g2.selectAll('g').data(testData).enter().append('g'); // console.log('g',g);\n      // let g3=g.enter().append('g');\n      // g3.append('text').attr('x',d=>xScale(xValue(d[0].data))+margin.left).attr('y',d=>yScale(d[0][1])+margin.top).text(d=>xValue(d[0].data))\n\n      let g4 = g2.selectAll('g').selectAll('rect').data(d => d).join(enter => enter.append('rect').attr('fill', function (d) {\n        return d3.interpolateSpectral(keys.indexOf(d.key) / 8);\n      }).attr('x', d => {\n        // console.log('x',xScale(xValue(d.data))+margin.left)\n        return xScale(xValue(d.data)) + margin.left - 5;\n      }).attr('y', d => yScale(d[1]) + margin.top).attr('height', d => yScale(d[0]) - yScale(d[1])), update => update //     .attr('x',d=>{\n      //     console.log(this)\n      //     if(d.count===count&&d.count>=xLength){\n      //         return xScale(xValue(d.data))+margin.left\n      //     }\n      //     else return this.x\n      // })\n      ); // .attr('cx',(d,i,node)=>{\n      //     console.log('node',node);\n      //     if(xValue(d.data)===0&&i!==0)\n      //         return xScale(xValue(d.data))+margin.left\n      //     else return(node[i].cx)\n      // })\n\n      g4.filter((d, i) => {\n        return xValue(d.data) === 0;\n      }).attr('fill', function (d) {\n        // console.log('count',d.count)\n        return d3.interpolateSpectral(keys.indexOf(d.key) / 8);\n      }).attr('x', d => {\n        // console.log('next!!')\n        return xScale(xValue(d.data)) + margin.left - 5;\n      }).attr('y', d => yScale(d[1]) + margin.top) // .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n      .attr('width', 0);\n      let p1 = g4.transition().duration(delay).attr('fill', function (d) {\n        return d3.interpolateSpectral(keys.indexOf(d.key) / 8);\n      }).attr('x', d => {\n        // console.log('x',xScale(xValue(d.data))+margin.left)\n        return xScale(xValue(d.data)) + margin.left - 5;\n      }).attr('y', d => yScale(d[1]) + margin.top).attr('height', d => yScale(d[0]) - yScale(d[1])).attr('width', 10).end();\n      let g5 = g2.selectAll('g').selectAll('text').data(d => d).join('text').text((d, i, node) => {\n        // console.log('d12',d);\n        if (i === 6) return getTime(d.data);else return null;\n      }).attr('dy', \".2em\").attr('font-size', \"8\");\n      g5.filter(d => {\n        return xValue(d.data) === 0;\n      }).attr('x', d => xScale(xValue(d.data)) + margin.left - 12).attr('y', d => yScale(d[1]) + margin.top);\n      g5.transition().duration(delay).attr('x', d => xScale(xValue(d.data)) + margin.left - 12).attr('y', d => yScale(d[1]) + margin.top); // g3.selectAll('circle').data(d=>d).enter().append('circle')\n      //     .transition()\n      //     .duration(2000)\n      //     .attr('r',10).attr('cy',d=>yScale(d[1])+margin.top).attr('cx',d=>xScale(xValue(d.data))+margin.left);\n      // console.log('g3',)\n      //如果界面满了就不再增加数据量\n\n      for (let i = 0; i < popNum; i++) {\n        tmpData.pop();\n      }\n\n      let t = [];\n      tmpData.forEach((d, index) => {\n        let m = [d[0], d[1]];\n        m.data = d.data;\n        m.key = d.key;\n        m.n = index;\n        m.count = d.count;\n        t.push(m);\n      });\n      console.log('t.len', t.length); // console.log('t',t);\n      // console.log('tmpData',tmpData);\n      // let s1=group.selectAll('rect')\n      //     .data(t,d=>d.n)\n      // .join(\n      //         enter=>enter.append('rect')\n      //             .attr('fill', function (d) {\n      //                 return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n      //             })\n      //             .attr('x', d =>{\n      //                 // console.log('x',xScale(xValue(d.data))+margin.left)\n      //                 return xScale(xValue(d.data))+margin.left\n      //             } )\n      //             .attr('y',d => (yScale(d[1])+margin.top))\n      //             .attr('height',d=>(yScale(d[0])-yScale(d[1]))),\n      //\n      //         update=>update\n      //         //     .attr('x',d=>{\n      //         //     console.log(this)\n      //         //     if(d.count===count&&d.count>=xLength){\n      //         //         return xScale(xValue(d.data))+margin.left\n      //         //     }\n      //         //     else return this.x\n      //         // })\n      //     )\n      // //要选择的是坐标轴最后一个数据而不是最新的数据！！！而最后一个的当前数据的时间是0点\n      // let f=group.selectAll('rect')\n      //     .filter(d=>xValue(d.data)===0&&d.count>1)\n      //     .attr('fill', function (d) {\n      //         // console.log('count',d.count)\n      //         return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n      //     })\n      //     .attr('x', d =>{\n      //         // console.log('next!!')\n      //         return xScale(xValue(d.data))+margin.left\n      //     } )\n      //     .attr('y',d => (yScale(d[1])+margin.top))\n      //     // .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n      //      .attr('width',0)\n      //\n      // let p1=s1.transition()\n      //     .duration(800)\n      //     .attr('fill', function (d) {\n      //         return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n      //     })\n      //     .attr('x', d =>{\n      //         // console.log('x',xScale(xValue(d.data))+margin.left)\n      //         return xScale(xValue(d.data))+margin.left\n      //     } )\n      //     .attr('y',d => (yScale(d[1])+margin.top))\n      //     .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n      //     .attr('width',10)\n      //     .end()\n      // let p2=s1.enter().append('rect')\n      //     .attr('fill', function (d) {\n      //         return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n      //     })\n      //     .attr('x', d =>{\n      //         // console.log('x',xScale(xValue(d.data))+margin.left)\n      //         return xScale(xValue(d.data))+margin.left\n      //     } )\n      //     .attr('y',d => (yScale(d[1])+margin.top))\n      //     .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n      //     // .attr('stroke', function (d) { return d3.interpolateSpectral(keys.indexOf(d[0].data[d.index]/8)); })\n      //     // .transition()\n      //     // .duration(2000)\n      //     .transition()\n      //     .duration(1000)\n      //     .attr('width',10)\n      //     .end();\n      // let p2= p.enter().append('rect')\n      //      .attr('fill', function (d) {\n      //    return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n      //    })\n      //    .transition()\n      //    .duration(2000)\n      //    .attr('x', d =>{\n      //        console.log('x',xScale(xValue(d.data))+margin.left)\n      //        return xScale(xValue(d.data))+margin.left\n      //    } )\n      //    .attr('y',d => (yScale(d[1])+margin.top))\n      //    .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n      //    // .attr('stroke', function (d) { return d3.interpolateSpectral(keys.indexOf(d[0].data[d.index]/8)); })\n      //    // .transition()\n      //    // .duration(2000)\n      //    .attr('width',10)\n      //     .end()\n\n      p1.then(() => {\n        if (count < rectData.length - 1) {\n          // let p2=group.transition()\n          //     .duration(1000)\n          //     .attr(\"transform\", `translate(${xScale(1)-xScale(0)},0)`)\n          //     .end()\n          // p2.then(()=>{\n          count++; // tmpData=tmpData.slice(0,2);\n          // console.log('tmpData1',tmpData);\n          // console.log('t1',t)\n\n          update(); // }\n          // )\n        } else {// callback()\n            // count=0;\n          }\n      });\n    }\n\n    update(); // stacked.map((x,index)=>{\n    //     // if(index!==0){\n    //     //     return\n    //     // }\n    //     svg.selectAll('rect')\n    //         .data(x)\n    //\n    // })\n    // let p=\n    //     .end();\n    // p.then(r=>{\n    //     callback()\n    // })\n  }\n\n  return null;\n};\n_c = Marks;\n\nvar _c;\n\n$RefreshReg$(_c, \"Marks\");","map":{"version":3,"sources":["/home/zhiguangda/ITS/deckgl/src/components/Barchart/Marks.js"],"names":["React","d3","Marks","data","xScale","xValue","yScale","innerHeight","innerWidth","margin","keys","start","callback","svg","select","xLength","getTime","d","date","Date","hour","getHours","day","getDate","delay","stack","offset","stackOffsetNone","order","stackOrderNone","colorScale","scaleOrdinal","range","schemeCategory10","area","x","left","y0","top","y1","curve","curveBasis","slice","stacked","domain","length","extent","min","series","max","rectData","map","t","index","key","undefined","push","group","append","g2","count","tmpData","groupCount","testData","update","popNum","unshift","pop","forEach","g","selectAll","enter","g4","join","attr","interpolateSpectral","indexOf","filter","i","p1","transition","duration","end","g5","text","node","m","n","console","log","then"],"mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACDkC,MAAAA,EAAE,CAACW,IAAH,CAAQ,MAAI;AACR,YAAG9B,KAAK,GAAEV,QAAQ,CAACL,MAAT,GAAgB,CAA1B,EAA6B;AACzB;AACA;AACA;AACA;AACA;AACIe,UAAAA,KAAK,GANgB,CAOrB;AAEJ;AACA;;AACII,UAAAA,MAAM,GAXe,CAYrB;AACJ;AAEH,SAfD,MAgBI,CACA;AACA;AACH;AACJ,OArBD;AAsBH;;AAEDA,IAAAA,MAAM,GAvVF,CAyVJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACH;;AAED,SAAO,IAAP;AAEH,CApZM;KAAM9D,K","sourcesContent":["import React from 'react';\nimport * as d3 from \"d3\";\n\nexport const Marks = ({\n                          data,\n                          xScale,\n                          xValue,\n                          yScale,\n                          innerHeight,\n                          innerWidth,\n                          margin,\n                          keys,\n                            start,\n                          callback\n                      }) =>{\n\n    const svg=d3.select('svg');\n\n    const xLength=24;\n    const getTime=d=>{\n        let date=new Date(d.date);\n        let hour=date.getHours();\n        let day=date.getDate();\n        return day+'/'+hour+':00'\n\n    }\n\n    const delay=1000;\n\n    let stack = d3.stack()//\n        .offset(d3.stackOffsetNone)\n        .order(d3.stackOrderNone);\n\n\n    var colorScale = d3.scaleOrdinal()\n        .range(d3.schemeCategory10);\n\n    var area = d3.area()\n        .x(d => xScale(xValue(d.data))+margin.left)\n        .y0(d => (yScale(d[0])+margin.top))\n        .y1(d => (yScale(d[1])+margin.top))\n        .curve(d3.curveBasis);\n\n\n    if(data){\n        data=data.slice(19,139);\n        // console.log(keys)\n        stack.keys(keys);\n        // console.log('data',data);\n        let stacked=stack(data);\n        // console.log('stack',stacked);\n\n        colorScale.domain(d3.range(keys.length));\n\n        xScale\n            .domain(d3.extent(data, xValue))\n            .range([0, innerWidth]);\n        yScale\n            .domain([\n                d3.min(stacked, function (series) {\n                    return d3.min(series, function (d) { return d[0]; });\n                }),\n                d3.max(stacked, function (series) {\n                    return d3.max(series, function (d) { return d[1]; });\n                })\n            ])\n            .range([ innerHeight,0]);\n\n\n        let rectData=[];\n//stack的数据结构：\n//      //数组里面7个元素分别对应7个地点\n//      //每个元素又是一个数组有24个元素分别对应24小时\n/*       (7) [Array(24), Array(24), Array(24), Array(24), Array(24), Array(24), Array(24)]\n0: Array(24)\n0: (2) [0, 19.3671431509997, data: {…}, key: \"San Francisco\"]\n1: (2) [0, 20.8082012083461, data: {…}, key: \"San Francisco\"]\n2: (2) [0, 22.5238576663828, data: {…}, key: \"San Francisco\"]\n3: (2) [0, 24.4214051463704, data: {…}, key: \"San Francisco\"]\n4: (2) [0, 26.2049693716955, data: {…}, key: \"San Francisco\"]\n5: (2) [0, 26.579802484894, data: {…}, key: \"San Francisco\"]\n6: (2) [0, 26.5525094442272, data: {…}, key: \"San Francisco\"]\n7: (2) [0, 23.9758724990251, data: {…}, key: \"San Francisco\"]\n8: (2) [0, 20.7705334007582, data: {…}, key: \"San Francisco\"]\n9: (2) [0, 19.5826361563267, data: {…}, key: \"San Francisco\"]\n10: (2) [0, 18.7265399946616, data: {…}, key: \"San Francisco\"]\n11: (2) [0, 18.2886029132647, data: {…}, key: \"San Francisco\"]\n12: (2) [0, 17.4904771411586, data: {…}, key: \"San Francisco\"]\n13: (2) [0, 17.1831430954037, data: {…}, key: \"San Francisco\"]\n14: (2) [0, 17.2898856656444, data: {…}, key: \"San Francisco\"]\n15: (2) [0, 17.8578100360021, data: {…}, key: \"San Francisco\"]\n16: (2) [0, 18.1992192220978, data: {…}, key: \"San Francisco\"]\n17: (2) [0, 18.13420905954, data: {…}, key: \"San Francisco\"]\n18: (2) [0, 18.5888149684944, data: {…}, key: \"San Francisco\"]\n19: (2) [0, 18.6733003026984, data: {…}, key: \"San Francisco\"]\n20: (2) [0, 19.1600833190036, data: {…}, key: \"San Francisco\"]\n21: (2) [0, 19.207095797011, data: {…}, key: \"San Francisco\"]\n22: (2) [0, 18.9847082241235, data: {…}, key: \"San Francisco\"]\n23: (2) [0, 19.4293802064908, data: {…}, key: \"San Francisco\"]\nkey: \"San Francisco\"\nindex: 0\nlength: 24\n__proto__: Array(0)\n1: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Bangalore\", index: 1]\n2: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Boston\", index: 2]\n3: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Geneva\", index: 3]\n4: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Rio de Janeiro\", index: 4]\n5: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Shanghai\", index: 5]\n6: (24) [Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), Array(2), key: \"Singapore\", index: 6]\nlength: 7\n__proto__: Array(0)*/\n//\n//把 stack 再转换成按时间分组的数据，其实data就是按时间分组的，但是为了计算出堆叠出来的数据所以用的了stack\n        stacked.map(x=>{\n            x.map((t,index)=>{\n                t.key=x.key;\n                if(rectData[index]===undefined){\n                    rectData[index]=[]\n                }\n                rectData[index].push(t);\n            })\n        })\n\n        // console.log('rectData',rectData)\n\n\n        const group=svg.append('g');\n        const g2=svg.append('g');\n        let count=0;\n        let tmpData=[];\n\n\n        let groupCount=[];\n\n        // tmpData.forEach(d=>{d.n=tmpData.indexOf(d)})\n        let testData=[];\n\n        function update(){\n            let popNum=0;\n            groupCount.unshift(rectData[count].length);\n            if(groupCount.length>xLength){\n                // console.log('24')\n                popNum=groupCount.pop()\n            }\n            //tmpData 里面是每一个小矩形的数据(到目前为止所有插入的矩形)，如何对这些矩形计数呢从而和时间对应\n            //无论你有多少数据我都只取前24组时间内的数据//不对啊我这样做出来的效果并不是时间轴跟着动而是这个温度变成下一个时刻的温度这样的动态效果，最好试用的例子是不同年龄段的人随着时间变化的过程，并不是温度\n            rectData[count].forEach(d=>{\n                    d.count=count;\n                    tmpData.unshift(d)\n                }\n            );\n\n            testData.unshift(\n                    rectData[count]\n\n                );\n            // console.log('testData',xValue(testData[0][0].data))\n            if(testData.length>xLength)testData.pop();\n            // console.log('testData',testData)\n            let g=g2.selectAll('g').data(testData).enter().append('g');\n            // console.log('g',g);\n            // let g3=g.enter().append('g');\n            // g3.append('text').attr('x',d=>xScale(xValue(d[0].data))+margin.left).attr('y',d=>yScale(d[0][1])+margin.top).text(d=>xValue(d[0].data))\n            let g4=g2.selectAll('g')\n                .selectAll('rect')\n                .data(d=>d)\n                .join(\n                    enter=>enter.append('rect')\n                        .attr('fill', function (d) {\n                            return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n                        })\n                        .attr('x', d =>{\n                            // console.log('x',xScale(xValue(d.data))+margin.left)\n                            return xScale(xValue(d.data))+margin.left-5\n                        } )\n                        .attr('y',d => (yScale(d[1])+margin.top))\n                        .attr('height',d=>(yScale(d[0])-yScale(d[1]))),\n\n                    update=>update\n                    //     .attr('x',d=>{\n                    //     console.log(this)\n                    //     if(d.count===count&&d.count>=xLength){\n                    //         return xScale(xValue(d.data))+margin.left\n                    //     }\n                    //     else return this.x\n                    // })\n                )\n\n                // .attr('cx',(d,i,node)=>{\n                //     console.log('node',node);\n                //     if(xValue(d.data)===0&&i!==0)\n                //         return xScale(xValue(d.data))+margin.left\n                //     else return(node[i].cx)\n                // })\n            g4.filter((d,i)=>{\n                return xValue(d.data)===0\n            }).attr('fill', function (d) {\n                // console.log('count',d.count)\n                return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n            })\n                .attr('x', d =>{\n                    // console.log('next!!')\n                    return xScale(xValue(d.data))+margin.left-5\n                } )\n                .attr('y',d => (yScale(d[1])+margin.top))\n                // .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n                .attr('width',0)\n\n\n            let p1=g4.transition()\n                .duration(delay)\n                .attr('fill', function (d) {\n                    return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n                })\n                .attr('x', d =>{\n                    // console.log('x',xScale(xValue(d.data))+margin.left)\n                    return xScale(xValue(d.data))+margin.left-5\n                } )\n                .attr('y',d => (yScale(d[1])+margin.top))\n                .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n                .attr('width',10)\n                .end()\n\n            let g5=g2.selectAll('g').selectAll('text')\n                .data(d=>d)\n                .join('text')\n                .text((d,i,node)=>{\n                    // console.log('d12',d);\n                    if (i===6) return getTime(d.data);\n                    else return null\n                })\n                .attr('dy',\".2em\")\n                .attr('font-size',\"8\")\n\n\n            g5.filter(d=>{\n                return xValue(d.data)===0\n            }).attr('x',d=>xScale(xValue(d.data))+margin.left-12)\n                .attr('y',d=>yScale(d[1])+margin.top)\n\n            g5.transition()\n                .duration(delay)\n                .attr('x',d=>xScale(xValue(d.data))+margin.left-12)\n                .attr('y',d=>yScale(d[1])+margin.top)\n            // g3.selectAll('circle').data(d=>d).enter().append('circle')\n            //     .transition()\n            //     .duration(2000)\n            //     .attr('r',10).attr('cy',d=>yScale(d[1])+margin.top).attr('cx',d=>xScale(xValue(d.data))+margin.left);\n\n            // console.log('g3',)\n\n\n\n\n\n            //如果界面满了就不再增加数据量\n            for(let i=0;i<popNum;i++){\n                tmpData.pop()\n            }\n            let t=[];\n            tmpData.forEach((d,index)=>{\n                let m=[d[0],d[1]];\n                m.data=d.data;\n                m.key=d.key;\n                m.n=index;\n                m.count=d.count\n                t.push(m)\n            });\n            console.log('t.len',t.length)\n\n\n\n\n            // console.log('t',t);\n            // console.log('tmpData',tmpData);\n            // let s1=group.selectAll('rect')\n            //     .data(t,d=>d.n)\n            // .join(\n            //         enter=>enter.append('rect')\n            //             .attr('fill', function (d) {\n            //                 return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n            //             })\n            //             .attr('x', d =>{\n            //                 // console.log('x',xScale(xValue(d.data))+margin.left)\n            //                 return xScale(xValue(d.data))+margin.left\n            //             } )\n            //             .attr('y',d => (yScale(d[1])+margin.top))\n            //             .attr('height',d=>(yScale(d[0])-yScale(d[1]))),\n            //\n            //         update=>update\n            //         //     .attr('x',d=>{\n            //         //     console.log(this)\n            //         //     if(d.count===count&&d.count>=xLength){\n            //         //         return xScale(xValue(d.data))+margin.left\n            //         //     }\n            //         //     else return this.x\n            //         // })\n            //     )\n            // //要选择的是坐标轴最后一个数据而不是最新的数据！！！而最后一个的当前数据的时间是0点\n            // let f=group.selectAll('rect')\n            //     .filter(d=>xValue(d.data)===0&&d.count>1)\n            //     .attr('fill', function (d) {\n            //         // console.log('count',d.count)\n            //         return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n            //     })\n            //     .attr('x', d =>{\n            //         // console.log('next!!')\n            //         return xScale(xValue(d.data))+margin.left\n            //     } )\n            //     .attr('y',d => (yScale(d[1])+margin.top))\n            //     // .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n            //      .attr('width',0)\n            //\n            // let p1=s1.transition()\n            //     .duration(800)\n            //     .attr('fill', function (d) {\n            //         return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n            //     })\n            //     .attr('x', d =>{\n            //         // console.log('x',xScale(xValue(d.data))+margin.left)\n            //         return xScale(xValue(d.data))+margin.left\n            //     } )\n            //     .attr('y',d => (yScale(d[1])+margin.top))\n            //     .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n            //     .attr('width',10)\n            //     .end()\n            // let p2=s1.enter().append('rect')\n            //     .attr('fill', function (d) {\n            //         return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n            //     })\n            //     .attr('x', d =>{\n            //         // console.log('x',xScale(xValue(d.data))+margin.left)\n            //         return xScale(xValue(d.data))+margin.left\n            //     } )\n            //     .attr('y',d => (yScale(d[1])+margin.top))\n            //     .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n            //     // .attr('stroke', function (d) { return d3.interpolateSpectral(keys.indexOf(d[0].data[d.index]/8)); })\n            //     // .transition()\n            //     // .duration(2000)\n            //     .transition()\n            //     .duration(1000)\n            //     .attr('width',10)\n            //     .end();\n\n\n\n             // let p2= p.enter().append('rect')\n             //      .attr('fill', function (d) {\n             //    return d3.interpolateSpectral(keys.indexOf(d.key)/8);\n             //    })\n             //    .transition()\n             //    .duration(2000)\n             //    .attr('x', d =>{\n             //        console.log('x',xScale(xValue(d.data))+margin.left)\n             //        return xScale(xValue(d.data))+margin.left\n             //    } )\n             //    .attr('y',d => (yScale(d[1])+margin.top))\n             //    .attr('height',d=>(yScale(d[0])-yScale(d[1])))\n             //    // .attr('stroke', function (d) { return d3.interpolateSpectral(keys.indexOf(d[0].data[d.index]/8)); })\n             //    // .transition()\n             //    // .duration(2000)\n             //    .attr('width',10)\n             //     .end()\n            p1.then(()=>{\n                if(count<(rectData.length-1)){\n                    // let p2=group.transition()\n                    //     .duration(1000)\n                    //     .attr(\"transform\", `translate(${xScale(1)-xScale(0)},0)`)\n                    //     .end()\n                    // p2.then(()=>{\n                        count++;\n                        // tmpData=tmpData.slice(0,2);\n\n                    // console.log('tmpData1',tmpData);\n                    // console.log('t1',t)\n                        update()\n                        // }\n                    // )\n\n                }\n                else{\n                    // callback()\n                    // count=0;\n                }\n            })\n        }\n\n        update();\n\n        // stacked.map((x,index)=>{\n        //     // if(index!==0){\n        //     //     return\n        //     // }\n        //     svg.selectAll('rect')\n        //         .data(x)\n        //\n        // })\n        // let p=\n        //     .end();\n\n        // p.then(r=>{\n        //     callback()\n        // })\n    }\n\n    return null;\n\n}\n"]},"metadata":{},"sourceType":"module"}