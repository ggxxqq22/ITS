{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { Matrix4 } from 'math.gl';\nimport { MVTLoader } from '@loaders.gl/mvt';\nimport { load } from '@loaders.gl/core';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { getURLFromTemplate } from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\nvar WORLD_SIZE = 512;\nvar defaultProps = {\n  uniqueIdProperty: {\n    type: 'string',\n    value: ''\n  },\n  highlightedFeatureId: null\n};\n\nvar MVTLayer = function (_TileLayer) {\n  _inherits(MVTLayer, _TileLayer);\n\n  var _super = _createSuper(MVTLayer);\n\n  function MVTLayer() {\n    _classCallCheck(this, MVTLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MVTLayer, [{\n    key: \"getTileData\",\n    value: function getTileData(tile) {\n      var url = getURLFromTemplate(this.props.data, tile);\n\n      if (!url) {\n        return Promise.reject('Invalid URL');\n      }\n\n      var options = this.getLoadOptions();\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        mvt: _objectSpread(_objectSpread({}, options && options.mvt), {}, {\n          coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n          tileIndex: {\n            x: tile.x,\n            y: tile.y,\n            z: tile.z\n          }\n        })\n      });\n      return load(url, MVTLoader, options);\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      var tile = props.tile;\n      var worldScale = Math.pow(2, tile.z);\n      var xScale = WORLD_SIZE / worldScale;\n      var yScale = -xScale;\n      var xOffset = WORLD_SIZE * tile.x / worldScale;\n      var yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n      var modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n      props.autoHighlight = false;\n\n      if (!this.context.viewport.resolution) {\n        props.modelMatrix = modelMatrix;\n        props.coordinateOrigin = [xOffset, yOffset, 0];\n        props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n        props.extensions = [].concat(_toConsumableArray(props.extensions || []), [new ClipExtension()]);\n      }\n\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"renderSubLayers\", this).call(this, props);\n    }\n  }, {\n    key: \"onHover\",\n    value: function onHover(info, pickingEvent) {\n      var _this$props = this.props,\n          uniqueIdProperty = _this$props.uniqueIdProperty,\n          autoHighlight = _this$props.autoHighlight;\n\n      if (autoHighlight) {\n        var hoveredFeatureId = this.state.hoveredFeatureId;\n        var hoveredFeature = info.object;\n        var newHoveredFeatureId;\n\n        if (hoveredFeature) {\n          newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n        }\n\n        if (hoveredFeatureId !== newHoveredFeatureId && newHoveredFeatureId !== -1) {\n          this.setState({\n            hoveredFeatureId: newHoveredFeatureId\n          });\n        }\n      }\n\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"onHover\", this).call(this, info, pickingEvent);\n    }\n  }, {\n    key: \"getHighlightedObjectIndex\",\n    value: function getHighlightedObjectIndex(tile) {\n      var hoveredFeatureId = this.state.hoveredFeatureId;\n      var _this$props2 = this.props,\n          uniqueIdProperty = _this$props2.uniqueIdProperty,\n          highlightedFeatureId = _this$props2.highlightedFeatureId;\n      var data = tile.data;\n      var isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n\n      if (!isFeatureIdPresent || !Array.isArray(data)) {\n        return -1;\n      }\n\n      var featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId) ? highlightedFeatureId : hoveredFeatureId;\n      return data.findIndex(function (feature) {\n        return getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n      });\n    }\n  }]);\n\n  return MVTLayer;\n}(TileLayer);\n\nexport { MVTLayer as default };\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return -1;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/mvt-layer/mvt-layer.js"],"names":["WORLD_SIZE","defaultProps","uniqueIdProperty","type","value","highlightedFeatureId","MVTLayer","TileLayer","tile","url","getURLFromTemplate","Promise","options","mvt","coordinates","tileIndex","x","y","z","load","props","worldScale","Math","xScale","yScale","xOffset","yOffset","modelMatrix","COORDINATE_SYSTEM","info","pickingEvent","autoHighlight","hoveredFeatureId","hoveredFeature","newHoveredFeatureId","getFeatureUniqueId","data","isFeatureIdPresent","isFeatureIdDefined","Array","featureIdToHighlight","feature"],"mappings":"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","sourcesContent":["import {Matrix4} from 'math.gl';\nimport {MVTLoader} from '@loaders.gl/mvt';\nimport {load} from '@loaders.gl/core';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\n\nimport TileLayer from '../tile-layer/tile-layer';\nimport {getURLFromTemplate} from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps = {\n  uniqueIdProperty: {type: 'string', value: ''},\n  highlightedFeatureId: null\n};\n\nexport default class MVTLayer extends TileLayer {\n  getTileData(tile) {\n    const url = getURLFromTemplate(this.props.data, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let options = this.getLoadOptions();\n    options = {\n      ...options,\n      mvt: {\n        ...(options && options.mvt),\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: {x: tile.x, y: tile.y, z: tile.z}\n      }\n    };\n    return load(url, MVTLoader, options);\n  }\n\n  renderSubLayers(props) {\n    const {tile} = props;\n    const worldScale = Math.pow(2, tile.z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    return super.renderSubLayers(props);\n  }\n\n  onHover(info, pickingEvent) {\n    const {uniqueIdProperty, autoHighlight} = this.props;\n\n    if (autoHighlight) {\n      const {hoveredFeatureId} = this.state;\n      const hoveredFeature = info.object;\n      let newHoveredFeatureId;\n\n      if (hoveredFeature) {\n        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      }\n\n      if (hoveredFeatureId !== newHoveredFeatureId && newHoveredFeatureId !== -1) {\n        this.setState({hoveredFeatureId: newHoveredFeatureId});\n      }\n    }\n\n    return super.onHover(info, pickingEvent);\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {hoveredFeatureId} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId} = this.props;\n    const {data} = tile;\n\n    const isFeatureIdPresent =\n      isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n\n    if (!isFeatureIdPresent || !Array.isArray(data)) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId)\n      ? highlightedFeatureId\n      : hoveredFeatureId;\n\n    return data.findIndex(\n      feature => getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight\n    );\n  }\n}\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return -1;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}