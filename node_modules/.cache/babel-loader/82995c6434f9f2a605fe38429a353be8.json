{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { dashShaders, offsetShaders } from './shaders.glsl';\nvar defaultProps = {\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getOffset: {\n    type: 'accessor',\n    value: 0\n  },\n  dashJustified: false\n};\n\nvar PathStyleExtension = function (_LayerExtension) {\n  _inherits(PathStyleExtension, _LayerExtension);\n\n  function PathStyleExtension() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$dash = _ref.dash,\n        dash = _ref$dash === void 0 ? false : _ref$dash,\n        _ref$offset = _ref.offset,\n        offset = _ref$offset === void 0 ? false : _ref$offset;\n\n    _classCallCheck(this, PathStyleExtension);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathStyleExtension).call(this, {\n      dash: dash,\n      offset: offset\n    }));\n  }\n\n  _createClass(PathStyleExtension, [{\n    key: \"isEnabled\",\n    value: function isEnabled(layer) {\n      return layer.state.pathTesselator;\n    }\n  }, {\n    key: \"getShaders\",\n    value: function getShaders(extension) {\n      if (!extension.isEnabled(this)) {\n        return null;\n      }\n\n      var result = {};\n\n      if (extension.opts.dash) {\n        result = mergeShaders(result, dashShaders);\n      }\n\n      if (extension.opts.offset) {\n        result = mergeShaders(result, offsetShaders);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState(context, extension) {\n      var attributeManager = this.getAttributeManager();\n\n      if (!attributeManager || !extension.isEnabled(this)) {\n        return;\n      }\n\n      extension.enabled = true;\n\n      if (extension.opts.dash) {\n        attributeManager.addInstanced({\n          instanceDashArrays: {\n            size: 2,\n            accessor: 'getDashArray'\n          }\n        });\n      }\n\n      if (extension.opts.offset) {\n        attributeManager.addInstanced({\n          instanceOffsets: {\n            size: 1,\n            accessor: 'getOffset'\n          }\n        });\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(params, extension) {\n      if (!extension.isEnabled(this)) {\n        return;\n      }\n\n      var uniforms = {};\n\n      if (extension.opts.dash) {\n        uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n      }\n\n      this.state.model.setUniforms(uniforms);\n    }\n  }]);\n\n  return PathStyleExtension;\n}(LayerExtension);\n\nexport { PathStyleExtension as default };\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/path-style/path-style.js"],"names":["_mergeShaders","defaultProps","getDashArray","type","value","getOffset","dashJustified","PathStyleExtension","LayerExtension","dash","offset","layer","extension","result","mergeShaders","context","attributeManager","instanceDashArrays","size","accessor","instanceOffsets","params","uniforms"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false\n};\n\nexport default class PathStyleExtension extends LayerExtension {\n  constructor({dash = false, offset = false} = {}) {\n    super({dash, offset});\n  }\n\n  isEnabled(layer) {\n    return layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    extension.enabled = true;\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'}\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n}\n\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}