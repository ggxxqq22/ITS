{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseImport = parseImport;\n\nvar _togeojson = require(\"@tmcw/togeojson\");\n\nvar _core = require(\"@loaders.gl/core\");\n\nvar _wkt = require(\"@loaders.gl/wkt\");\n/* eslint-env browser */\n\n\nfunction shouldTryGeoJson(data) {\n  return data.startsWith('{');\n}\n\nfunction shouldTryKml(data) {\n  return data.startsWith('<');\n}\n\nfunction shouldTryWkt(data) {\n  return data.startsWith('POINT') || data.startsWith('LINESTRING') || data.startsWith('POLYGON') || data.startsWith('MULTIPOINT') || data.startsWith('MULTILINESTRING') || data.startsWith('MULTIPOLYGON');\n}\n\nfunction getCleanedFeatures(geojson) {\n  if (geojson.type !== 'FeatureCollection' && geojson.type !== 'Feature') {\n    throw Error(\"GeoJSON must have type of 'Feature' or 'FeatureCollection'\");\n  }\n\n  var features = geojson.type === 'FeatureCollection' ? geojson.features : [geojson];\n  return features.map(getCleanedFeature);\n}\n\nfunction getCleanedFeature(feature) {\n  var id = feature.id; // reduce null-checking\n\n  var properties = feature.properties || {};\n  var geometry = feature.geometry; // @ts-ignore\n\n  if (geometry.type === 'GeometryCollection' && geometry.geometries.length === 1) {\n    // There's only one geometry\n    // @ts-ignore\n    geometry = geometry.geometries[0]; // @ts-ignore\n  } else if (geometry.type === 'GeometryCollection' && geometry.geometries.length > 1) {\n    // @ts-ignore\n    var types = new Set(geometry.geometries.map(function (g) {\n      return g.type;\n    }));\n\n    if (types.size === 1) {\n      // See if it can be combined into a Multi* geometry\n      var type = types.values().next().value;\n\n      if (type === 'Polygon') {\n        // Combine all the Polygons into a single MultiPolygon\n        geometry = {\n          type: 'MultiPolygon',\n          // @ts-ignore\n          coordinates: geometry.geometries.map(function (g) {\n            return g.coordinates;\n          })\n        };\n      } else if (type === 'LineString') {\n        // Combine all the LineStrings into a single MultiLineString\n        geometry = {\n          type: 'MultiLineString',\n          // @ts-ignore\n          coordinates: geometry.geometries.map(function (g) {\n            return g.coordinates;\n          })\n        };\n      }\n    } else {\n      // Mixed geometry types, we don't yet handle it\n      throw Error('GeometryCollection geometry type not yet supported');\n    }\n  } // @ts-ignore\n\n\n  return {\n    type: 'Feature',\n    id: id,\n    geometry: geometry,\n    properties: properties\n  };\n}\n\nfunction parseImportString(data) {\n  data = data.trim();\n  var validData;\n  var validationErrors = [];\n\n  if (shouldTryGeoJson(data)) {\n    // Parse as GeoJSON\n    try {\n      var parsed = JSON.parse(data);\n      validData = {\n        valid: true,\n        type: 'GeoJSON',\n        features: getCleanedFeatures(parsed)\n      };\n    } catch (err) {\n      validationErrors.push('Error parsing GeoJSON');\n      validationErrors.push(err.toString());\n    }\n  } else if (shouldTryKml(data)) {\n    // Parse as KML\n    var xml = new DOMParser().parseFromString(data, 'text/xml');\n\n    try {\n      var _parsed = (0, _togeojson.kml)(xml);\n      /*\n      TODO: Revisit using loaders.gl/kml for this later\n      const parsed_ = parseSync(data, KMLasGeoJsonLoader);\n      // This is changing the coordinates to floats, because in loaders.gl/kml 2.1.1 they are returned as strings.\n      const parsed = {\n        ...parsed_,\n        features: parsed_.features.map(f => ({\n          ...f,\n          geometry: {\n            ...f.geometry,\n            coordinates: f.geometry.coordinates.map(coords => coords.map(triple => triple.map(s => Number.parseFloat(s))))\n          }\n        }))\n      };\n      */\n\n\n      var isFeature = _parsed && _parsed.type === 'Feature';\n      var isFeatureCollectionWithFeatures = _parsed && _parsed.type === 'FeatureCollection' && _parsed.features.length > 0;\n      var isValid = isFeature || isFeatureCollectionWithFeatures;\n\n      if (isValid) {\n        validData = {\n          valid: true,\n          type: 'KML',\n          features: getCleanedFeatures(_parsed)\n        };\n      } else {\n        validationErrors.push('Invalid KML');\n      }\n    } catch (err) {\n      validationErrors.push('Error parsing KML');\n      validationErrors.push(err.toString());\n    }\n  } else if (shouldTryWkt(data)) {\n    try {\n      var _parsed2 = (0, _core.parseSync)(data, _wkt.WKTLoader);\n\n      if (_parsed2) {\n        validData = {\n          valid: true,\n          type: 'WKT',\n          features: [{\n            type: 'Feature',\n            properties: {},\n            geometry: _parsed2\n          }]\n        };\n      } else {\n        validationErrors.push('Invalid WKT');\n      }\n    } catch (err) {\n      validationErrors.push('Error parsing WKT');\n      validationErrors.push(err.toString());\n    }\n  } else {\n    validationErrors.push('Unknown data format');\n  }\n\n  if (validData) {\n    return Promise.resolve(validData);\n  }\n\n  return Promise.resolve({\n    valid: false,\n    validationErrors: validationErrors\n  });\n}\n\nfunction parseImportFile(file) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onload = function () {\n      var fileAsString = reader.result;\n      resolve(parseImportString(fileAsString));\n    };\n\n    reader.onabort = function () {\n      reject(Error('file reading was aborted'));\n    };\n\n    reader.onerror = function () {\n      reject(Error('file reading has failed'));\n    };\n\n    reader.readAsText(file);\n  });\n}\n\nfunction parseImport(data) {\n  if (typeof data === 'string') {\n    return parseImportString(data);\n  }\n\n  return parseImportFile(data);\n}","map":{"version":3,"sources":["../../src/lib/importer.ts"],"names":["data","geojson","Error","features","id","feature","properties","geometry","types","g","type","coordinates","validationErrors","shouldTryGeoJson","parsed","JSON","validData","valid","getCleanedFeatures","err","shouldTryKml","xml","isFeature","isFeatureCollectionWithFeatures","isValid","shouldTryWkt","WKTLoader","Promise","reader","fileAsString","resolve","parseImportString","reject","parseImportFile"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\nimport { kml } from '@tmcw/togeojson';\n\nimport { parseSync } from '@loaders.gl/core';\nimport { WKTLoader } from '@loaders.gl/wkt';\n\n// If we want to support node -- we need to import xmldom.\n// For now, we're only supporting browser so we can leave it out.\n// import { DOMParser } from 'xmldom';\nimport { AnyGeoJson, Feature } from '@nebula.gl/edit-modes';\n\nexport type ValidImportData = {\n  valid: true;\n  type: 'GeoJSON' | 'KML' | 'WKT';\n  features: Feature[];\n};\n\nexport type InvalidImportData = {\n  valid: false;\n  validationErrors: string[];\n};\n\nexport type ImportData = ValidImportData | InvalidImportData;\n\nfunction shouldTryGeoJson(data: string): boolean {\n  return data.startsWith('{');\n}\n\nfunction shouldTryKml(data: string): boolean {\n  return data.startsWith('<');\n}\n\nfunction shouldTryWkt(data: string): boolean {\n  return (\n    data.startsWith('POINT') ||\n    data.startsWith('LINESTRING') ||\n    data.startsWith('POLYGON') ||\n    data.startsWith('MULTIPOINT') ||\n    data.startsWith('MULTILINESTRING') ||\n    data.startsWith('MULTIPOLYGON')\n  );\n}\n\nfunction getCleanedFeatures(geojson: AnyGeoJson): Feature[] {\n  if (geojson.type !== 'FeatureCollection' && geojson.type !== 'Feature') {\n    throw Error(`GeoJSON must have type of 'Feature' or 'FeatureCollection'`);\n  }\n\n  const features: Feature[] = geojson.type === 'FeatureCollection' ? geojson.features : [geojson];\n\n  return features.map(getCleanedFeature);\n}\n\nfunction getCleanedFeature(feature: Feature): Feature {\n  const { id } = feature;\n  // reduce null-checking\n  const properties = feature.properties || {};\n\n  let geometry = feature.geometry;\n  // @ts-ignore\n  if (geometry.type === 'GeometryCollection' && geometry.geometries.length === 1) {\n    // There's only one geometry\n    // @ts-ignore\n    geometry = geometry.geometries[0];\n    // @ts-ignore\n  } else if (geometry.type === 'GeometryCollection' && geometry.geometries.length > 1) {\n    // @ts-ignore\n    const types = new Set(geometry.geometries.map((g) => g.type));\n    if (types.size === 1) {\n      // See if it can be combined into a Multi* geometry\n      const type = types.values().next().value;\n      if (type === 'Polygon') {\n        // Combine all the Polygons into a single MultiPolygon\n        geometry = {\n          type: 'MultiPolygon',\n          // @ts-ignore\n          coordinates: geometry.geometries.map((g) => g.coordinates),\n        };\n      } else if (type === 'LineString') {\n        // Combine all the LineStrings into a single MultiLineString\n        geometry = {\n          type: 'MultiLineString',\n          // @ts-ignore\n          coordinates: geometry.geometries.map((g) => g.coordinates),\n        };\n      }\n    } else {\n      // Mixed geometry types, we don't yet handle it\n      throw Error('GeometryCollection geometry type not yet supported');\n    }\n  }\n\n  // @ts-ignore\n  return {\n    type: 'Feature',\n    id,\n    geometry,\n    properties,\n  };\n}\n\nfunction parseImportString(data: string): Promise<ImportData> {\n  data = data.trim();\n  let validData: ValidImportData | null | undefined;\n  const validationErrors: string[] = [];\n  if (shouldTryGeoJson(data)) {\n    // Parse as GeoJSON\n    try {\n      const parsed = JSON.parse(data);\n      validData = {\n        valid: true,\n        type: 'GeoJSON',\n        features: getCleanedFeatures(parsed),\n      };\n    } catch (err) {\n      validationErrors.push('Error parsing GeoJSON');\n      validationErrors.push(err.toString());\n    }\n  } else if (shouldTryKml(data)) {\n    // Parse as KML\n    const xml = new DOMParser().parseFromString(data, 'text/xml');\n\n    try {\n      const parsed = kml(xml);\n\n      /*\n      TODO: Revisit using loaders.gl/kml for this later\n      const parsed_ = parseSync(data, KMLasGeoJsonLoader);\n      // This is changing the coordinates to floats, because in loaders.gl/kml 2.1.1 they are returned as strings.\n      const parsed = {\n        ...parsed_,\n        features: parsed_.features.map(f => ({\n          ...f,\n          geometry: {\n            ...f.geometry,\n            coordinates: f.geometry.coordinates.map(coords => coords.map(triple => triple.map(s => Number.parseFloat(s))))\n          }\n        }))\n      };\n      */\n      const isFeature = parsed && parsed.type === 'Feature';\n      const isFeatureCollectionWithFeatures =\n        parsed && parsed.type === 'FeatureCollection' && parsed.features.length > 0;\n      const isValid = isFeature || isFeatureCollectionWithFeatures;\n      if (isValid) {\n        validData = {\n          valid: true,\n          type: 'KML',\n          features: getCleanedFeatures(parsed),\n        };\n      } else {\n        validationErrors.push('Invalid KML');\n      }\n    } catch (err) {\n      validationErrors.push('Error parsing KML');\n      validationErrors.push(err.toString());\n    }\n  } else if (shouldTryWkt(data)) {\n    try {\n      const parsed = parseSync(data, WKTLoader);\n      if (parsed) {\n        validData = {\n          valid: true,\n          type: 'WKT',\n          features: [\n            {\n              type: 'Feature',\n              properties: {},\n              geometry: parsed,\n            },\n          ],\n        };\n      } else {\n        validationErrors.push('Invalid WKT');\n      }\n    } catch (err) {\n      validationErrors.push('Error parsing WKT');\n      validationErrors.push(err.toString());\n    }\n  } else {\n    validationErrors.push('Unknown data format');\n  }\n\n  if (validData) {\n    return Promise.resolve(validData);\n  }\n  return Promise.resolve({\n    valid: false,\n    validationErrors,\n  });\n}\n\nfunction parseImportFile(file: File): Promise<ImportData> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const fileAsString: any = reader.result;\n      resolve(parseImportString(fileAsString));\n    };\n    reader.onabort = () => {\n      reject(Error('file reading was aborted'));\n    };\n    reader.onerror = () => {\n      reject(Error('file reading has failed'));\n    };\n\n    reader.readAsText(file);\n  });\n}\n\nexport function parseImport(data: string | File): Promise<ImportData> {\n  if (typeof data === 'string') {\n    return parseImportString(data);\n  }\n  return parseImportFile(data);\n}\n"]},"metadata":{},"sourceType":"script"}