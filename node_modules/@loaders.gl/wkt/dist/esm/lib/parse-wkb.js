import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
var NUM_DIMENSIONS = {
  0: 2,
  1: 3,
  2: 3,
  3: 4
};
export default function parseWKB(buffer) {
  var view = new DataView(buffer);
  var offset = 0;
  var littleEndian = view.getUint8(offset) === 1;
  offset++;
  var geometryCode = view.getUint32(offset, littleEndian);
  offset += 4;
  var geometryType = geometryCode % 1000;
  var dimension = NUM_DIMENSIONS[(geometryCode - geometryType) / 1000];

  switch (geometryType) {
    case 1:
      var point = parsePoint(view, offset, dimension, littleEndian);
      delete point.offset;
      point.type = 'Point';
      return point;

    case 2:
      var line = parseLineString(view, offset, dimension, littleEndian);
      delete line.offset;
      line.type = 'LineString';
      return line;

    case 3:
      var polygon = parsePolygon(view, offset, dimension, littleEndian);
      delete polygon.offset;
      polygon.type = 'Polygon';
      return polygon;

    case 4:
      var multiPoint = parseMultiPoint(view, offset, dimension, littleEndian);
      multiPoint.type = 'Point';
      return multiPoint;

    case 5:
      var multiLine = parseMultiLineString(view, offset, dimension, littleEndian);
      multiLine.type = 'LineString';
      return multiLine;

    case 6:
      var multiPolygon = parseMultiPolygon(view, offset, dimension, littleEndian);
      multiPolygon.type = 'Polygon';
      return multiPolygon;

    default:
      assert(false, "Unsupported geometry type: ".concat(geometryType));
  }

  return null;
}

function parsePoint(view, offset, dimension, littleEndian) {
  var positions = new Float64Array(dimension);

  for (var i = 0; i < dimension; i++) {
    positions[i] = view.getFloat64(offset, littleEndian);
    offset += 8;
  }

  return {
    positions: {
      value: positions,
      size: dimension
    },
    offset: offset
  };
}

function parseLineString(view, offset, dimension, littleEndian) {
  var nPoints = view.getUint32(offset, littleEndian);
  offset += 4;
  var positions = new Float64Array(nPoints * dimension);

  for (var i = 0; i < nPoints * dimension; i++) {
    positions[i] = view.getFloat64(offset, littleEndian);
    offset += 8;
  }

  var pathIndices = [0];

  if (nPoints > 0) {
    pathIndices.push(nPoints);
  }

  return {
    positions: {
      value: positions,
      size: dimension
    },
    pathIndices: {
      value: new Uint16Array(pathIndices),
      size: 1
    },
    offset: offset
  };
}

var cumulativeSum = function cumulativeSum(sum) {
  return function (value) {
    return sum += value;
  };
};

function parsePolygon(view, offset, dimension, littleEndian) {
  var nRings = view.getUint32(offset, littleEndian);
  offset += 4;
  var rings = [];

  for (var i = 0; i < nRings; i++) {
    var parsed = parseLineString(view, offset, dimension, littleEndian);
    var positions = parsed.positions;
    offset = parsed.offset;
    rings.push(positions.value);
  }

  var concatenatedPositions = new Float64Array(concatTypedArrays(rings).buffer);
  var polygonIndices = [0];

  if (concatenatedPositions.length > 0) {
    polygonIndices.push(concatenatedPositions.length / dimension);
  }

  var primitivePolygonIndices = rings.map(function (l) {
    return l.length / dimension;
  }).map(cumulativeSum(0));
  primitivePolygonIndices.unshift(0);
  return {
    positions: {
      value: concatenatedPositions,
      size: dimension
    },
    polygonIndices: {
      value: new Uint16Array(polygonIndices),
      size: 1
    },
    primitivePolygonIndices: {
      value: new Uint16Array(primitivePolygonIndices),
      size: 1
    },
    offset: offset
  };
}

function parseMultiPoint(view, offset, dimension, littleEndian) {
  var nPoints = view.getUint32(offset, littleEndian);
  offset += 4;
  var points = [];

  for (var i = 0; i < nPoints; i++) {
    var littleEndianPoint = view.getUint8(offset) === 1;
    offset++;
    assert(view.getUint32(offset, littleEndianPoint) % 1000 === 1, 'Inner geometries of MultiPoint not of type Point');
    offset += 4;
    var parsed = parsePoint(view, offset, dimension, littleEndianPoint);
    var positions = parsed.positions;
    offset = parsed.offset;
    points.push(positions.value);
  }

  var concatenatedPositions = new Float64Array(concatTypedArrays(points).buffer);
  return {
    positions: {
      value: concatenatedPositions,
      size: dimension
    }
  };
}

function parseMultiLineString(view, offset, dimension, littleEndian) {
  var nLines = view.getUint32(offset, littleEndian);
  offset += 4;
  var lines = [];

  for (var i = 0; i < nLines; i++) {
    var littleEndianLine = view.getUint8(offset) === 1;
    offset++;
    assert(view.getUint32(offset, littleEndianLine) % 1000 === 2, 'Inner geometries of MultiLineString not of type LineString');
    offset += 4;
    var parsed = parseLineString(view, offset, dimension, littleEndianLine);
    var positions = parsed.positions;
    offset = parsed.offset;
    lines.push(positions.value);
  }

  var concatenatedPositions = new Float64Array(concatTypedArrays(lines).buffer);
  var pathIndices = lines.map(function (l) {
    return l.length / dimension;
  }).map(cumulativeSum(0));
  pathIndices.unshift(0);
  return {
    positions: {
      value: concatenatedPositions,
      size: dimension
    },
    pathIndices: {
      value: new Uint16Array(pathIndices),
      size: 1
    }
  };
}

function parseMultiPolygon(view, offset, dimension, littleEndian) {
  var nPolygons = view.getUint32(offset, littleEndian);
  offset += 4;
  var polygons = [];
  var primitivePolygons = [];

  for (var i = 0; i < nPolygons; i++) {
    var littleEndianPolygon = view.getUint8(offset) === 1;
    offset++;
    assert(view.getUint32(offset, littleEndianPolygon) % 1000 === 3, 'Inner geometries of MultiPolygon not of type Polygon');
    offset += 4;
    var parsed = parsePolygon(view, offset, dimension, littleEndianPolygon);
    var positions = parsed.positions,
        _primitivePolygonIndices = parsed.primitivePolygonIndices;
    offset = parsed.offset;
    polygons.push(positions.value);
    primitivePolygons.push(_primitivePolygonIndices.value);
  }

  var concatenatedPositions = new Float64Array(concatTypedArrays(polygons).buffer);
  var polygonIndices = polygons.map(function (p) {
    return p.length / dimension;
  }).map(cumulativeSum(0));
  polygonIndices.unshift(0);
  var primitivePolygonIndices = [0];

  for (var _i = 0, _primitivePolygons = primitivePolygons; _i < _primitivePolygons.length; _i++) {
    var primitivePolygon = _primitivePolygons[_i];
    primitivePolygonIndices.push.apply(primitivePolygonIndices, _toConsumableArray(primitivePolygon.filter(function (x) {
      return x > 0;
    }).map(function (x) {
      return x + primitivePolygonIndices[primitivePolygonIndices.length - 1];
    })));
  }

  return {
    positions: {
      value: concatenatedPositions,
      size: dimension
    },
    polygonIndices: {
      value: new Uint16Array(polygonIndices),
      size: 1
    },
    primitivePolygonIndices: {
      value: new Uint16Array(primitivePolygonIndices),
      size: 1
    }
  };
}

function concatTypedArrays(arrays) {
  var byteLength = 0;

  for (var i = 0; i < arrays.length; ++i) {
    byteLength += arrays[i].byteLength;
  }

  var buffer = new Uint8Array(byteLength);
  var byteOffset = 0;

  for (var _i2 = 0; _i2 < arrays.length; ++_i2) {
    var data = new Uint8Array(arrays[_i2].buffer);
    byteLength = data.length;

    for (var j = 0; j < byteLength; ++j) {
      buffer[byteOffset++] = data[j];
    }
  }

  return buffer;
}

function assert(condition, message) {
  if (!condition) {
    throw new Error("Error parsing Well-Known Binary. ".concat(message));
  }
}
//# sourceMappingURL=parse-wkb.js.map